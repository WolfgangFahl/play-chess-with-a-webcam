{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"play-chess-with-a-webcam API Documentation","text":""},{"location":"#pcwawc.args","title":"<code>args</code>","text":"<p>Created on 2019-12-08</p> <p>@author: wf</p>"},{"location":"#pcwawc.args.Args","title":"<code>Args</code>","text":"<p>Command Line argument handling</p> Source code in <code>pcwawc/args.py</code> <pre><code>class Args:\n    \"\"\"Command Line argument handling\"\"\"\n\n    def __init__(self, description):\n        self.parser = argparse.ArgumentParser(description=description)\n        self.parser.add_argument(\n            \"--input\", default=\"0\", help=\"Manually set the input device.\"\n        )\n        self.parser.add_argument(\n            \"--autowarp\",\n            action=\"store_true\",\n            help=\"automatically find and warp chessboard\",\n        )\n\n        self.parser.add_argument(\"--black\", default=None, help=\"PGN Black header\")\n\n        self.parser.add_argument(\n            \"--debug\", action=\"store_true\", help=\"show debug output\"\n        )\n\n        self.parser.add_argument(\n            \"--detector\", default=\"simple8x8\", help=\"move detector to be used\"\n        )\n\n        self.parser.add_argument(\"--event\", default=None, help=\"PGN Event header\")\n\n        self.parser.add_argument(\n            \"--fen\", default=None, help=\"Forsyth\u2013Edwards Notation to start with\"\n        )\n\n        self.parser.add_argument(\"--game\", default=None, help=\"game to initialize with\")\n\n        self.parser.add_argument(\n            \"--lichess\", action=\"store_true\", help=\"activate lichess integration\"\n        )\n\n        self.parser.add_argument(\n            \"--nomoves\", action=\"store_true\", help=\"do not show each individual move\"\n        )\n\n        self.parser.add_argument(\n            \"--nowarp\",\n            action=\"store_true\",\n            help=\"chessboard vision is already squared e.g. recorded that way\",\n        )\n\n        self.parser.add_argument(\"--round\", default=None, help=\"PGN Round header\")\n\n        self.parser.add_argument(\n            \"--rotation\",\n            type=int,\n            default=0,\n            help=\"rotation of chessboard 0,90,180 or 270\",\n        )\n\n        self.parser.add_argument(\"--site\", default=None, help=\"PGN Site header\")\n\n        self.parser.add_argument(\n            \"--startframe\",\n            type=int,\n            default=0,\n            help=\"video frame at which to start detection\",\n        )\n\n        self.parser.add_argument(\n            \"--speedup\",\n            type=int,\n            default=1,\n            help=\"detection speedup - higher speedup means less precision\",\n        )\n\n        self.parser.add_argument(\"--white\", default=None, help=\"PGN White header\")\n\n        self.parser.add_argument(\"--warp\", default=\"[]\", help=\"warp points\")\n\n        self.parser.add_argument(\n            \"--distance\",\n            type=int,\n            default=5,\n            help=\"detection pixel distance - number of pixels analyzed i square of this\",\n        )\n\n        self.parser.add_argument(\n            \"--step\",\n            type=int,\n            default=3,\n            help=\"detection pixel steps - distance*step is the grid size being analyzed\",\n        )\n\n        pass\n\n    def parse(self, argv):\n        self.args = self.parser.parse_args(argv)\n        self.args.warpPointList = ast.literal_eval(self.args.warp)\n        return self.args\n</code></pre>"},{"location":"#pcwawc.board","title":"<code>board</code>","text":""},{"location":"#pcwawc.board.Board","title":"<code>Board</code>","text":"<p>               Bases: <code>object</code></p> <p>This class is used to hold the state of a chessboard with pieces positions and the current player's color which player needs to play. It uses the python-chess library by default</p> Source code in <code>pcwawc/board.py</code> <pre><code>@implementer(IChessBoard)\nclass Board(object):\n    \"\"\"This class is used to hold the state of a chessboard with pieces positions and the current player's color which player needs to play. It uses the python-chess library by default\"\"\"\n\n    debug = False\n    EMPTY_FEN = \"8/8/8/8/8/8/8/8 w - -\"\n    START_FEN = chess.STARTING_BOARD_FEN\n\n    # initialize the board\n    def __init__(self, args=None):\n        self.chessboard = chess.Board()\n        self.fieldsByAn = {}\n        self.args = args\n        self.debug = self.args is not None and self.args.debug\n        self.game = WebCamGame.fromArgs(args)\n        self.updateFen()\n        self.game.update(self)\n\n        self.fields = [[0 for x in range(Field.rows)] for y in range(Field.cols)]\n        for row in range(Field.rows):\n            for col in range(Field.cols):\n                field = Field(self, row, col)\n                self.fieldsByAn[field.an] = field\n                self.fields[col][row] = field\n\n    def fieldAt(self, row, col):\n        return self.fields[col][row]\n\n    def genSquares(self):\n        for field in self.fieldsByAn.values():\n            yield field\n\n    def divideInSquares(self, width, height):\n        # interpolate the centers of the 8x8 fields from a squared image\n        fieldHeight = height / Field.rows\n        fieldWidth = width / Field.cols\n        for field in self.genSquares():\n            field.setRect(width, height, fieldWidth, fieldHeight)\n\n    def fieldStateCounts(self):\n        # there are 6 different FieldStats\n        counts = [0, 0, 0, 0, 0, 0]\n        for field in self.fieldsByAn.values():\n            fieldState = field.getFieldState()\n            counts[fieldState] = counts[fieldState] + 1\n        return counts\n\n    def piecesOfColor(self, color):\n        count = 0\n        for field in self.fieldsByAn.values():\n            piece = field.getPiece()\n            if piece is not None and piece.color == color:\n                count = count + 1\n        return count\n\n    # perform the given move\n    def performMove(self, move):\n        fromCell, toCell = move\n        return self.ucimove(fromCell + toCell)\n\n    def ucimove(self, ucimove):\n        move = Move.from_uci(ucimove.lower())\n        return self.move(move)\n\n    def move(self, move):\n        \"\"\"perform the given move\"\"\"\n        try:\n            if self.debug:\n                print(\"trying to perform move %s on\" % (str(move)))\n                print(\"%s\" % (self.unicode()))\n            san = self.chessboard.san(move)\n        except Exception as e:\n            if self.debug:\n                print(\"failed with error: %s\" % (str(e)))\n            return None\n\n        self.chessboard.push(move)\n        self.game.move(self)\n        self.updateFen()\n        if self.args is not None and not self.args.nomoves:\n            print(\"move %s\" % (san))\n            print(\"%s\" % (self.unicode()))\n        return san\n\n    def takeback(self):\n        if self.game.moveIndex &gt; 0:\n            self.game.moveIndex = self.game.moveIndex - 1\n            self.chessboard.pop()\n            self.updateFen()\n            return True\n        else:\n            return False\n\n    def lockGame(self):\n        # @TODO implement locking of a saved game to make it immutable\n        gameid = self.game.gameid\n        self.game.locked = True\n        return gameid\n\n    # set my board and game from the given pgn\n    def setPgn(self, pgn):\n        self.game.pgn = pgn\n        pgnIo = io.StringIO(pgn)\n        game = chess.pgn.read_game(pgnIo)\n        if game is None:\n            # TODO log a warning\n            return\n        self.chessboard = game.board()\n        for move in game.mainline_moves():\n            self.chessboard.push(move)\n        self.updateFen()\n\n    def updatePieces(self, fen):\n        self.chessboard = chess.Board(fen)\n        self.updateFen()\n\n    # get my fen description\n    def updateFen(self):\n        self.fen = self.chessboard.board_fen()\n        self.game.fen = self.fen\n        return self.fen\n\n    # get my unicode representation\n    def unicode(self):\n        unicode = self.chessboard.unicode()\n        return unicode\n\n    def changeToMove(self, change):\n        sq1, sq2 = change\n        \"\"\" convert the given change in the physical board to a move \"\"\"\n        for move in self.chessboard.legal_moves:\n            movestr = str(move)\n            if sq1 + sq2 == movestr or sq2 + sq1 == movestr:\n                return move\n        return None\n</code></pre>"},{"location":"#pcwawc.board.Board.move","title":"<code>move(move)</code>","text":"<p>perform the given move</p> Source code in <code>pcwawc/board.py</code> <pre><code>def move(self, move):\n    \"\"\"perform the given move\"\"\"\n    try:\n        if self.debug:\n            print(\"trying to perform move %s on\" % (str(move)))\n            print(\"%s\" % (self.unicode()))\n        san = self.chessboard.san(move)\n    except Exception as e:\n        if self.debug:\n            print(\"failed with error: %s\" % (str(e)))\n        return None\n\n    self.chessboard.push(move)\n    self.game.move(self)\n    self.updateFen()\n    if self.args is not None and not self.args.nomoves:\n        print(\"move %s\" % (san))\n        print(\"%s\" % (self.unicode()))\n    return san\n</code></pre>"},{"location":"#pcwawc.boarddetector","title":"<code>boarddetector</code>","text":""},{"location":"#pcwawc.boarddetector.BoardDetector","title":"<code>BoardDetector</code>","text":"<p>               Bases: <code>Observable</code></p> <p>detect a chess board's state from the given image</p> Source code in <code>pcwawc/boarddetector.py</code> <pre><code>@implementer(IMoveDetector)\nclass BoardDetector(Observable):\n    \"\"\"detect a chess board's state from the given image\"\"\"\n\n    frameDebug = False\n\n    def __init__(self):\n        \"\"\"construct me\"\"\"\n        # make me observable\n        super(BoardDetector, self).__init__()\n        pass\n\n    def setup(self, name, vision):\n        self.name = name\n        self.vision = vision\n        self.board = vision.board\n        self.video = vision.video\n        self.hsv = None\n        self.debug = False\n\n    def sortByFieldState(self):\n        # get a dict of fields sorted by field state\n        sortedByFieldState = sorted(\n            self.board.fieldsByAn.values(), key=lambda field: field.getFieldState()\n        )\n        counts = self.board.fieldStateCounts()\n        sortedFields = {}\n        fromIndex = 0\n        for fieldState in FieldState:\n            toIndex = fromIndex + counts[fieldState]\n            sortedFields[fieldState] = sortedByFieldState[fromIndex:toIndex]\n            fromIndex = toIndex\n        return sortedFields\n\n    def analyzeFields(self, image, grid, roiLambda):\n        for field in self.board.genSquares():\n            field.divideInROIs(grid, roiLambda)\n            for roi in field.rois:\n                roi.analyze(image)\n\n    def analyzeColors(self, image, distance=3, step=1):\n        self.hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n        for field in self.board.genSquares():\n            field.analyzeColor(image, self.hsv, distance, step)\n\n    def onChessBoardImage(self, imageEvent):\n        cbImageSet = imageEvent.cbImageSet\n        vision = cbImageSet.vision\n        args = vision.args\n        distance = args.distance\n        step = args.step\n        return self.analyze(cbImageSet, distance, step)\n\n    # analyze the given image\n    def analyze(self, cbImageSet, distance=3, step=1):\n        frameIndex = cbImageSet.frameIndex\n        cbWarped = cbImageSet.cbWarped\n        image = cbWarped.image\n        self.board.divideInSquares(cbWarped.width, cbWarped.height)\n        self.analyzeColors(image, distance, step)\n        sortedFields = self.sortByFieldState()\n\n        if self.debug:\n            overlay = image.copy()\n\n        for fieldState, fields in sortedFields.items():\n            for field in fields:\n                l = field.luminance\n                if BoardDetector.frameDebug:\n                    print(\n                        \"frame %5d: %s luminance: %3.0f \u00b1 %3.0f (%d) rgbColorKey: %3.0f colorKey: %.0f\"\n                        % (\n                            frameIndex,\n                            field.an,\n                            l.mean(),\n                            l.standard_deviation(),\n                            l.n,\n                            field.rgbColorKey,\n                            field.colorKey,\n                        )\n                    )\n                if self.debug:\n                    field.drawDebug(self.video, overlay, fieldState)\n                    alpha = 0.6  # Transparency factor.\n                    # Following line overlays transparent rectangle over the image\n                    image_new = cv2.addWeighted(overlay, alpha, image, 1 - alpha, 0)\n                    image = image_new\n                    cbImageSet.cbDebug = ChessBoardImage(image, \"debug\")\n        return image\n</code></pre>"},{"location":"#pcwawc.boarddetector.BoardDetector.__init__","title":"<code>__init__()</code>","text":"<p>construct me</p> Source code in <code>pcwawc/boarddetector.py</code> <pre><code>def __init__(self):\n    \"\"\"construct me\"\"\"\n    # make me observable\n    super(BoardDetector, self).__init__()\n    pass\n</code></pre>"},{"location":"#pcwawc.boardfinder","title":"<code>boardfinder</code>","text":""},{"location":"#pcwawc.boardfinder.BoardFinder","title":"<code>BoardFinder</code>","text":"<p>               Bases: <code>object</code></p> <p>find a chess board in the given image</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>class BoardFinder(object):\n    \"\"\"find a chess board in the given image\"\"\"\n\n    debug = False\n    black = (0, 0, 0)\n    white = (255, 255, 255)\n    darkGrey = (256 // 3, 256 // 3, 256 / 3)\n    lightGrey = (256 * 2 // 3, 256 * 2 // 3, 256 * 2 // 3)\n\n    def __init__(self, image, video=None):\n        \"\"\"construct me from the given input image\"\"\"\n        if video is None:\n            video = Video()\n        self.video = video\n        self.image = image\n        # guess the topleft color\n        self.topleft = chess.WHITE\n        self.height, self.width = self.image.shape[:2]\n\n    @staticmethod\n    def centerXY(xylist):\n        x, y = zip(*xylist)\n        l = len(x)\n        return sum(x) / l, sum(y) / l\n\n    @staticmethod\n    def sortPoints(xylist):\n        \"\"\"sort points clockwise see https://stackoverflow.com/a/59115565/1497139\"\"\"\n        cx, cy = BoardFinder.centerXY(xylist)\n        xy_sorted = sorted(xylist, key=lambda x: math.atan2((x[1] - cy), (x[0] - cx)))\n        return xy_sorted\n\n    def findOuterCorners(self, searchWidth=640):\n        \"\"\"find my outer corners as limited by the OpenCV findChessBoard algorithm - to be later expanded\"\"\"\n        found = self.findCorners(self.image, limit=1, searchWidth=searchWidth)\n        # we expected to find a board\n        if len(found) != 1:\n            raise Exception(\"no corners found\")\n        chesspattern = next(iter(found))\n        corners = found[chesspattern]\n        corners.calcPolygons(0, Corners.safetyMargin)\n        corners.calcTrapez()\n        return corners\n\n    def preparefindCorners(self, image, searchWidth=640):\n        sw = self.width\n        sh = self.height\n        if sw &gt; searchWidth:\n            sw = searchWidth\n            sh = self.height * sw // self.width\n        searchimage = cv2.resize(self.image, (sw, sh))\n        if BoardFinder.debug:\n            print(\n                \"BoardFinder for %dx%d image resized to %dx%d\"\n                % (self.width, self.height, sw, sh)\n            )\n\n        gray = cv2.cvtColor(searchimage, cv2.COLOR_BGR2GRAY)\n        fullSizeGray = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)\n        return gray, fullSizeGray\n\n    def findCorners(self, image, limit=1, searchWidth=640):\n        \"\"\"start finding the chessboard with the given limit and the given maximum width of the search image\"\"\"\n        startt = timer()\n        gray, fullSizeGray = self.preparefindCorners(image, searchWidth)\n        self.found = {}\n        for chesspattern in Corners.genChessPatterns():\n            corners = Corners(chesspattern, self.video)\n            if corners.findPattern(gray) and corners.findPattern(fullSizeGray):\n                corners.sort()\n                self.found[chesspattern] = corners\n            if len(self.found) &gt;= limit:\n                break\n        endt = timer()\n        if BoardFinder.debug:\n            print(\"found %d patterns in %.1f s\" % (len(self.found), (endt - startt)))\n        return self.found\n\n    def findChessBoard(self, image, title):\n        \"\"\"find a chess board in the given image and return the trapez polygon for it\"\"\"\n        corners = self.findOuterCorners()\n        histograms = self.getHistograms(image, title, corners)\n        self.expand(image, title, histograms, corners)\n        return corners\n\n    def fieldColor(self, pos):\n        \"\"\"determine the field color at the given position\"\"\"\n        row, col = pos\n        # the color of the topleft field might be different then A8=WHITE when we have a rotated image\n        oddeven = 1 if self.topleft == chess.WHITE else 0\n        # calculate the chessboard color of the given position based on the topleft color\n        color = chess.WHITE if (col + row) % 2 == oddeven else chess.BLACK\n        return color\n\n    def maskPolygon(self, image, polygon):\n        \"\"\"mask the given image with the given polygon\"\"\"\n        mask = self.video.getEmptyImage(image)\n        cv2.fillConvexPoly(mask, polygon, BoardFinder.white)\n        masked = self.video.maskImage(image, mask)\n        return masked\n\n    def maskCornerPolygons(self, image, corners, filterColor):\n        \"\"\"mask the polygons derived from the given corner points\"\"\"\n        mask = self.video.getEmptyImage(image)\n        polygons = corners.polygons[Corners.safetyMargin]\n        for pos, polygon in polygons.items():\n            posColor = self.fieldColor(pos)\n            if not posColor == filterColor:\n                self.drawPolygon(\n                    mask, pos, polygon, BoardFinder.white, BoardFinder.white\n                )\n        # if BoardFinder.debug:\n        #    cv2.imshow(\"mask\",mask)\n        #    cv2.waitKey(1000)\n        masked = self.video.maskImage(image, mask)\n        return masked\n\n    def getHistograms(self, image, title, corners):\n        \"\"\"get the two histograms for the given corners we don't no what the color of the topleft corner is so we start with a guess\"\"\"\n        histograms = {}\n        for filterColor in (True, False):\n            imageCopy = image.copy()\n            masked = self.maskCornerPolygons(imageCopy, corners, filterColor)\n            if BoardFinder.debug:\n                prefix = \"masked-O-\" if filterColor else \"masked-X-\"\n                corners.writeDebug(masked, title, prefix)\n            histograms[filterColor] = Histogram(masked, histRange=(1, 256))\n\n        # do we need to fix our guess?\n        # is the mean color of black (being filtered) higher then when white is filtered?\n        if histograms[chess.BLACK].color &gt; histograms[chess.WHITE].color:\n            self.topleft = chess.BLACK\n            # swap entries\n            tmp = histograms[chess.BLACK]\n            histograms[chess.BLACK] = histograms[chess.WHITE]\n            histograms[chess.WHITE] = tmp\n        return histograms\n\n    def getColorFiltered(self, image, histograms, title, corners):\n        \"\"\"get color filtered images based on the given histograms\"\"\"\n        colorFiltered = {}\n        colorMask = {}\n        for filterColor in (chess.WHITE, chess.BLACK):\n            histogram = histograms[filterColor]\n            imageCopy = image.copy()\n            lowerColor, upperColor = histogram.range(1.0)\n            # make sure the colors are numpy arrays\n            lowerColor = np.array(lowerColor, dtype=np.uint8)\n            upperColor = np.array(upperColor, dtype=np.uint8)\n            # if we would know that the empty fields would be the extreme colors we could do the following:\n            # if filterColor==chess.WHITE:\n            #    upperColor=(255,255,255)\n            # else:\n            #    lowerColor=(0,0,0)\n            # lower,upper=histogram.mincolor, histogram.maxcolor\n            colorMask[filterColor] = cv2.inRange(imageCopy, lowerColor, upperColor)\n            # colorMask[filterColor]=histogram.colorMask(imageCopy, 1.5)\n            colorFiltered[filterColor] = self.video.maskImage(\n                imageCopy, colorMask[filterColor]\n            )\n            if BoardFinder.debug:\n                colorName = \"white\" if filterColor == chess.WHITE else \"black\"\n                bl, gl, rl = lowerColor\n                bu, gu, ru = upperColor\n                print(\n                    \"bgr %s: %3d-%3d, %3d-%3d, %3d-%3d\"\n                    % (colorName, bl, bu, gl, gu, rl, ru)\n                )\n                prefix = \"colorFiltered-%s-\" % (colorName)\n                corners.writeDebug(colorFiltered[filterColor], title, prefix)\n        backGroundFilter = cv2.bitwise_not(\n            cv2.bitwise_or(colorMask[chess.WHITE], colorMask[chess.BLACK])\n        )\n        imageCopy = image.copy()\n        colorFiltered[\"background\"] = self.video.maskImage(imageCopy, backGroundFilter)\n        if BoardFinder.debug:\n            corners.writeDebug(\n                colorFiltered[\"background\"], title, \"colorFiltered-background-\"\n            )\n        # side effect - add background histogram\n        histograms[\"background\"] = Histogram(\n            colorFiltered[\"background\"], histRange=(1, 256)\n        )\n        return colorFiltered\n\n    def expand(self, image, title, histograms, corners):\n        \"\"\"expand the image finding to 8x8 with the given histograms and corners that are e.g. 7x7,7x5,5x5, ...\"\"\"\n        if BoardFinder.debug:\n            corners.showTrapezDebug(image, title, corners)\n        # create a mask for the\n        masked8x8 = self.maskPolygon(image, corners.trapez8x8)\n        if BoardFinder.debug:\n            corners.writeDebug(masked8x8, title, \"trapez-masked\")\n        # draw a 10x10 sized white trapez\n        white10x10 = self.video.getEmptyImage(image)\n        cv2.fillConvexPoly(white10x10, corners.trapez10x10, BoardFinder.white)\n        cv2.fillConvexPoly(white10x10, corners.trapez8x8, BoardFinder.black)\n        masked10x10 = white10x10 + masked8x8\n        if BoardFinder.debug:\n            corners.writeDebug(masked10x10, title, \"trapez-white\")\n        # 9x9 test fails due to a few pixels which are in the way\n        # commented out to speed up\n        # gray8x8,fullSizeGray8x8=self.preparefindCorners(masked10x10)\n        # corners8x8=Corners((9,9),self.video)\n        # if corners8x8.findPattern(fullSizeGray8x8):\n        #    if BoardFinder.debug:\n        #        print(\"Successfully found 8x8 for %s\"+title)\n        self.colorFiltered = self.getColorFiltered(\n            masked8x8, histograms, title, corners\n        )\n\n    def drawPolygon(self, image, pos, polygon, whiteColor, blackColor):\n        posColor = self.fieldColor(pos)\n        color = blackColor if posColor else whiteColor\n        cv2.fillConvexPoly(image, polygon, color)\n\n    def showPolygonDebug(self, image, title, corners):\n        \"\"\"draw polygons for debugging on a copy of the given image with the given corners and write result to the debugImagePath with the given title\"\"\"\n        imagecopy = image.copy()\n        polygons = corners.polygons[0]\n        for pos, polygon in polygons.items():\n            self.drawPolygon(\n                imagecopy, pos, polygon, BoardFinder.lightGrey, BoardFinder.darkGrey\n            )\n            if Corners.debugSorting:\n                row, col = pos\n                text = \"%d,%d\" % (row, col)\n                x, y = BoardFinder.centerXY(polygon)\n                self.video.drawCenteredText(\n                    imagecopy, text, int(x), int(y), fontBGRColor=(255, 0, 0)\n                )\n        corners.writeDebug(imagecopy, title, \"polygons\")\n\n    def showHistogramDebug(self, histograms, title, corners):\n        \"\"\"'show' the debug information for the given histograms by writing a plotted histogram image to the debugImagePath\"\"\"\n        Environment.checkDir(Environment.debugImagePath)\n        fig, axes = histograms[True].preparePlot(3, 2)\n        histograms[True].plotRow(axes[0, 0], axes[0, 1])\n        histograms[False].plotRow(axes[1, 0], axes[1, 1])\n        histograms[\"background\"].plotRow(axes[2, 0], axes[2, 1])\n        prefix = \"histogram\"\n        filepath = Environment.debugImagePath + \"%s-%s-%dx%d.jpg\" % (\n            title,\n            prefix,\n            corners.rows,\n            corners.cols,\n        )\n        histograms[False].savefig(fig, filepath)\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.__init__","title":"<code>__init__(image, video=None)</code>","text":"<p>construct me from the given input image</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def __init__(self, image, video=None):\n    \"\"\"construct me from the given input image\"\"\"\n    if video is None:\n        video = Video()\n    self.video = video\n    self.image = image\n    # guess the topleft color\n    self.topleft = chess.WHITE\n    self.height, self.width = self.image.shape[:2]\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.expand","title":"<code>expand(image, title, histograms, corners)</code>","text":"<p>expand the image finding to 8x8 with the given histograms and corners that are e.g. 7x7,7x5,5x5, ...</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def expand(self, image, title, histograms, corners):\n    \"\"\"expand the image finding to 8x8 with the given histograms and corners that are e.g. 7x7,7x5,5x5, ...\"\"\"\n    if BoardFinder.debug:\n        corners.showTrapezDebug(image, title, corners)\n    # create a mask for the\n    masked8x8 = self.maskPolygon(image, corners.trapez8x8)\n    if BoardFinder.debug:\n        corners.writeDebug(masked8x8, title, \"trapez-masked\")\n    # draw a 10x10 sized white trapez\n    white10x10 = self.video.getEmptyImage(image)\n    cv2.fillConvexPoly(white10x10, corners.trapez10x10, BoardFinder.white)\n    cv2.fillConvexPoly(white10x10, corners.trapez8x8, BoardFinder.black)\n    masked10x10 = white10x10 + masked8x8\n    if BoardFinder.debug:\n        corners.writeDebug(masked10x10, title, \"trapez-white\")\n    # 9x9 test fails due to a few pixels which are in the way\n    # commented out to speed up\n    # gray8x8,fullSizeGray8x8=self.preparefindCorners(masked10x10)\n    # corners8x8=Corners((9,9),self.video)\n    # if corners8x8.findPattern(fullSizeGray8x8):\n    #    if BoardFinder.debug:\n    #        print(\"Successfully found 8x8 for %s\"+title)\n    self.colorFiltered = self.getColorFiltered(\n        masked8x8, histograms, title, corners\n    )\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.fieldColor","title":"<code>fieldColor(pos)</code>","text":"<p>determine the field color at the given position</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def fieldColor(self, pos):\n    \"\"\"determine the field color at the given position\"\"\"\n    row, col = pos\n    # the color of the topleft field might be different then A8=WHITE when we have a rotated image\n    oddeven = 1 if self.topleft == chess.WHITE else 0\n    # calculate the chessboard color of the given position based on the topleft color\n    color = chess.WHITE if (col + row) % 2 == oddeven else chess.BLACK\n    return color\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.findChessBoard","title":"<code>findChessBoard(image, title)</code>","text":"<p>find a chess board in the given image and return the trapez polygon for it</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def findChessBoard(self, image, title):\n    \"\"\"find a chess board in the given image and return the trapez polygon for it\"\"\"\n    corners = self.findOuterCorners()\n    histograms = self.getHistograms(image, title, corners)\n    self.expand(image, title, histograms, corners)\n    return corners\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.findCorners","title":"<code>findCorners(image, limit=1, searchWidth=640)</code>","text":"<p>start finding the chessboard with the given limit and the given maximum width of the search image</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def findCorners(self, image, limit=1, searchWidth=640):\n    \"\"\"start finding the chessboard with the given limit and the given maximum width of the search image\"\"\"\n    startt = timer()\n    gray, fullSizeGray = self.preparefindCorners(image, searchWidth)\n    self.found = {}\n    for chesspattern in Corners.genChessPatterns():\n        corners = Corners(chesspattern, self.video)\n        if corners.findPattern(gray) and corners.findPattern(fullSizeGray):\n            corners.sort()\n            self.found[chesspattern] = corners\n        if len(self.found) &gt;= limit:\n            break\n    endt = timer()\n    if BoardFinder.debug:\n        print(\"found %d patterns in %.1f s\" % (len(self.found), (endt - startt)))\n    return self.found\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.findOuterCorners","title":"<code>findOuterCorners(searchWidth=640)</code>","text":"<p>find my outer corners as limited by the OpenCV findChessBoard algorithm - to be later expanded</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def findOuterCorners(self, searchWidth=640):\n    \"\"\"find my outer corners as limited by the OpenCV findChessBoard algorithm - to be later expanded\"\"\"\n    found = self.findCorners(self.image, limit=1, searchWidth=searchWidth)\n    # we expected to find a board\n    if len(found) != 1:\n        raise Exception(\"no corners found\")\n    chesspattern = next(iter(found))\n    corners = found[chesspattern]\n    corners.calcPolygons(0, Corners.safetyMargin)\n    corners.calcTrapez()\n    return corners\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.getColorFiltered","title":"<code>getColorFiltered(image, histograms, title, corners)</code>","text":"<p>get color filtered images based on the given histograms</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def getColorFiltered(self, image, histograms, title, corners):\n    \"\"\"get color filtered images based on the given histograms\"\"\"\n    colorFiltered = {}\n    colorMask = {}\n    for filterColor in (chess.WHITE, chess.BLACK):\n        histogram = histograms[filterColor]\n        imageCopy = image.copy()\n        lowerColor, upperColor = histogram.range(1.0)\n        # make sure the colors are numpy arrays\n        lowerColor = np.array(lowerColor, dtype=np.uint8)\n        upperColor = np.array(upperColor, dtype=np.uint8)\n        # if we would know that the empty fields would be the extreme colors we could do the following:\n        # if filterColor==chess.WHITE:\n        #    upperColor=(255,255,255)\n        # else:\n        #    lowerColor=(0,0,0)\n        # lower,upper=histogram.mincolor, histogram.maxcolor\n        colorMask[filterColor] = cv2.inRange(imageCopy, lowerColor, upperColor)\n        # colorMask[filterColor]=histogram.colorMask(imageCopy, 1.5)\n        colorFiltered[filterColor] = self.video.maskImage(\n            imageCopy, colorMask[filterColor]\n        )\n        if BoardFinder.debug:\n            colorName = \"white\" if filterColor == chess.WHITE else \"black\"\n            bl, gl, rl = lowerColor\n            bu, gu, ru = upperColor\n            print(\n                \"bgr %s: %3d-%3d, %3d-%3d, %3d-%3d\"\n                % (colorName, bl, bu, gl, gu, rl, ru)\n            )\n            prefix = \"colorFiltered-%s-\" % (colorName)\n            corners.writeDebug(colorFiltered[filterColor], title, prefix)\n    backGroundFilter = cv2.bitwise_not(\n        cv2.bitwise_or(colorMask[chess.WHITE], colorMask[chess.BLACK])\n    )\n    imageCopy = image.copy()\n    colorFiltered[\"background\"] = self.video.maskImage(imageCopy, backGroundFilter)\n    if BoardFinder.debug:\n        corners.writeDebug(\n            colorFiltered[\"background\"], title, \"colorFiltered-background-\"\n        )\n    # side effect - add background histogram\n    histograms[\"background\"] = Histogram(\n        colorFiltered[\"background\"], histRange=(1, 256)\n    )\n    return colorFiltered\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.getHistograms","title":"<code>getHistograms(image, title, corners)</code>","text":"<p>get the two histograms for the given corners we don't no what the color of the topleft corner is so we start with a guess</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def getHistograms(self, image, title, corners):\n    \"\"\"get the two histograms for the given corners we don't no what the color of the topleft corner is so we start with a guess\"\"\"\n    histograms = {}\n    for filterColor in (True, False):\n        imageCopy = image.copy()\n        masked = self.maskCornerPolygons(imageCopy, corners, filterColor)\n        if BoardFinder.debug:\n            prefix = \"masked-O-\" if filterColor else \"masked-X-\"\n            corners.writeDebug(masked, title, prefix)\n        histograms[filterColor] = Histogram(masked, histRange=(1, 256))\n\n    # do we need to fix our guess?\n    # is the mean color of black (being filtered) higher then when white is filtered?\n    if histograms[chess.BLACK].color &gt; histograms[chess.WHITE].color:\n        self.topleft = chess.BLACK\n        # swap entries\n        tmp = histograms[chess.BLACK]\n        histograms[chess.BLACK] = histograms[chess.WHITE]\n        histograms[chess.WHITE] = tmp\n    return histograms\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.maskCornerPolygons","title":"<code>maskCornerPolygons(image, corners, filterColor)</code>","text":"<p>mask the polygons derived from the given corner points</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def maskCornerPolygons(self, image, corners, filterColor):\n    \"\"\"mask the polygons derived from the given corner points\"\"\"\n    mask = self.video.getEmptyImage(image)\n    polygons = corners.polygons[Corners.safetyMargin]\n    for pos, polygon in polygons.items():\n        posColor = self.fieldColor(pos)\n        if not posColor == filterColor:\n            self.drawPolygon(\n                mask, pos, polygon, BoardFinder.white, BoardFinder.white\n            )\n    # if BoardFinder.debug:\n    #    cv2.imshow(\"mask\",mask)\n    #    cv2.waitKey(1000)\n    masked = self.video.maskImage(image, mask)\n    return masked\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.maskPolygon","title":"<code>maskPolygon(image, polygon)</code>","text":"<p>mask the given image with the given polygon</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def maskPolygon(self, image, polygon):\n    \"\"\"mask the given image with the given polygon\"\"\"\n    mask = self.video.getEmptyImage(image)\n    cv2.fillConvexPoly(mask, polygon, BoardFinder.white)\n    masked = self.video.maskImage(image, mask)\n    return masked\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.showHistogramDebug","title":"<code>showHistogramDebug(histograms, title, corners)</code>","text":"<p>'show' the debug information for the given histograms by writing a plotted histogram image to the debugImagePath</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def showHistogramDebug(self, histograms, title, corners):\n    \"\"\"'show' the debug information for the given histograms by writing a plotted histogram image to the debugImagePath\"\"\"\n    Environment.checkDir(Environment.debugImagePath)\n    fig, axes = histograms[True].preparePlot(3, 2)\n    histograms[True].plotRow(axes[0, 0], axes[0, 1])\n    histograms[False].plotRow(axes[1, 0], axes[1, 1])\n    histograms[\"background\"].plotRow(axes[2, 0], axes[2, 1])\n    prefix = \"histogram\"\n    filepath = Environment.debugImagePath + \"%s-%s-%dx%d.jpg\" % (\n        title,\n        prefix,\n        corners.rows,\n        corners.cols,\n    )\n    histograms[False].savefig(fig, filepath)\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.showPolygonDebug","title":"<code>showPolygonDebug(image, title, corners)</code>","text":"<p>draw polygons for debugging on a copy of the given image with the given corners and write result to the debugImagePath with the given title</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def showPolygonDebug(self, image, title, corners):\n    \"\"\"draw polygons for debugging on a copy of the given image with the given corners and write result to the debugImagePath with the given title\"\"\"\n    imagecopy = image.copy()\n    polygons = corners.polygons[0]\n    for pos, polygon in polygons.items():\n        self.drawPolygon(\n            imagecopy, pos, polygon, BoardFinder.lightGrey, BoardFinder.darkGrey\n        )\n        if Corners.debugSorting:\n            row, col = pos\n            text = \"%d,%d\" % (row, col)\n            x, y = BoardFinder.centerXY(polygon)\n            self.video.drawCenteredText(\n                imagecopy, text, int(x), int(y), fontBGRColor=(255, 0, 0)\n            )\n    corners.writeDebug(imagecopy, title, \"polygons\")\n</code></pre>"},{"location":"#pcwawc.boardfinder.BoardFinder.sortPoints","title":"<code>sortPoints(xylist)</code>  <code>staticmethod</code>","text":"<p>sort points clockwise see https://stackoverflow.com/a/59115565/1497139</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>@staticmethod\ndef sortPoints(xylist):\n    \"\"\"sort points clockwise see https://stackoverflow.com/a/59115565/1497139\"\"\"\n    cx, cy = BoardFinder.centerXY(xylist)\n    xy_sorted = sorted(xylist, key=lambda x: math.atan2((x[1] - cy), (x[0] - cx)))\n    return xy_sorted\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners","title":"<code>Corners</code>","text":"<p>               Bases: <code>object</code></p> <p>Chess board corners</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>class Corners(object):\n    \"\"\"Chess board corners\"\"\"\n\n    debug = False\n    debugSorting = False\n    \"\"\" pixel margin for masked polygons\"\"\"\n    safetyMargin = 5\n\n    def __init__(self, pattern, video):\n        \"\"\"initialize me with the given rows and columns\"\"\"\n        self.pattern = pattern\n        self.rows, self.cols = pattern\n        self.video = video\n        # prepare the dict for my polygons\n        self.polygons = {}\n\n    @staticmethod\n    def genChessPatterns():\n        \"\"\"generate the patterns 7x7, 5x7, 3x7, 5x5, 5x3, 3x3\"\"\"\n        for rows in range(7, 2, -2):\n            for cols in range(7, rows - 2, -2):\n                yield (rows, cols)\n\n    @staticmethod\n    def sortXY(xy):\n        x, y = xy[0]\n        return x, y\n\n    def sort(self):\n        \"\"\"sort the corners - this step is currently not implemented so the corners stay rotated\"\"\"\n        if Corners.debugSorting:\n            print(\"trying to sort %d points\" % (len(self.corners)))\n        cornerssorted = sorted(self.corners, key=Corners.sortXY)\n        if Corners.debugSorting:\n            print(cornerssorted)\n        # self.corners = np.empty(shape=(len(self.corners),2),dtype=np.float32)\n        # for i,val in enumerate(cornerssorted):\n        #    self.corners[i]=val\n        pass\n\n    def findPattern(self, image):\n        \"\"\"try finding the chess board corners in the given image with the given pattern\"\"\"\n        self.h, self.w = image.shape[:2]\n\n        start = timer()\n        ret, self.corners = cv2.findChessboardCorners(image, self.pattern, None)\n        end = timer()\n        if Corners.debug:\n            print(\n                \"%dx%d in %dx%d after %.3f s: %s\"\n                % (\n                    self.rows,\n                    self.cols,\n                    self.w,\n                    self.h,\n                    (end - start),\n                    \"\u2714\" if ret else \"\u274c\",\n                )\n            )\n        return ret\n\n    def safeXY(self, x, y, dx, dy):\n        \"\"\"return the given x,y tuple shifted by dx,dy making sure the result is not out of my width and height bounds\"\"\"\n        x = x + dx\n        y = y + dy\n        if y &gt;= self.h:\n            y = self.h - 1\n        if y &lt; 0:\n            y = 0\n        if x &gt;= self.w:\n            x = self.w - 1\n        if x &lt; 0:\n            x = 0\n        return (x, y)\n\n    def asPolygons(self, safetyMargin):\n        \"\"\"get the polygons for my corner points\"\"\"\n        # reshape the array\n        cps = np.reshape(self.corners, (self.cols, self.rows, 2))\n        polygons = {}\n        m = safetyMargin\n        for col in range(self.cols - 1):\n            for row in range(self.rows - 1):\n                x1, y1 = cps[col, row]  # top left\n                x2, y2 = cps[col + 1, row]  # left bottom\n                x3, y3 = cps[col + 1, row + 1]  # right bottom\n                x4, y4 = cps[col, row + 1]  # top right\n                clockwise = BoardFinder.sortPoints(\n                    [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]\n                )\n                (x1, y1), (x2, y2), (x3, y3), (x4, y4) = clockwise\n                # https://stackoverflow.com/questions/19190484/what-is-the-opencv-findchessboardcorners-convention\n                polygon = np.array(\n                    [\n                        self.safeXY(x1, y1, +m, +m),\n                        self.safeXY(x2, y2, -m, +m),\n                        self.safeXY(x3, y3, -m, -m),\n                        self.safeXY(x4, y4, +m, -m),\n                    ],\n                    dtype=np.int32,\n                )\n                polygons[(col, self.rows - 2 - row)] = polygon\n        return polygons\n\n    def calcPolygons(self, *safetyMargins):\n        \"\"\"calculate polygons for the given safety margins\"\"\"\n        for safetyMargin in safetyMargins:\n            self.polygons[safetyMargin] = self.asPolygons(safetyMargin)\n\n    def calcTrapez(self):\n        \"\"\"calculate the relevant quadrilaterals\"\"\"\n        corners = self.corners\n        l = len(self.corners)\n        rowend = self.rows - 1\n        self.topLeft = corners[0]\n        self.topRight = corners[rowend]\n        self.bottomRight = corners[l - 1]\n        self.bottomLeft = corners[l - 1 - rowend]\n        self.trapez2Square = Trapez2Square(\n            self.topLeft, self.topRight, self.bottomRight, self.bottomLeft\n        )\n        self.trapez8x8 = self.trapezColRows(8, 8)\n        self.trapez10x10 = self.trapezColRows(10, 10)\n        self.trapez = self.trapez2Square.relativeTrapezToTrapezXY(0, 0, 1, 1)\n        pass\n\n    def trapezColRows(self, cols, rows):\n        \"\"\"return an expanded trapez with the given number of columns and rows\"\"\"\n        relDeltaRows = (rows / (self.rows - 1) - 1) / 2\n        relDeltaCols = (cols / (self.cols - 1) - 1) / 2\n        trapez = self.trapez2Square.relativeTrapezToTrapezXY(\n            -relDeltaRows, -relDeltaCols, 1 + relDeltaRows, 1 + relDeltaCols\n        )\n        return trapez\n\n    def showTrapezDebug(self, image, title, corners):\n        \"\"\"'show' a debug picture with the extrapolated quadrilaterals by writing an image to the debugImagePath\"\"\"\n        overlay = image.copy()\n        # draw polytons from outer to inner\n        cv2.fillConvexPoly(overlay, self.trapez10x10, (0, 165, 255))  # orange\n        cv2.fillConvexPoly(overlay, self.trapez8x8, (128, 128, 128))  # grey\n        cv2.fillConvexPoly(overlay, self.trapez, (225, 105, 65))  # royal blue\n        alpha = 0.8  # Transparency factor.\n        # overlay the\n        imageAlpha = cv2.addWeighted(overlay, alpha, image, 1 - alpha, 0)\n        corners.writeDebug(imageAlpha, title, \"trapez\")\n\n    def showDebug(self, image, title):\n        \"\"\"'show' the debug picture of the chessboard corners by drawing the corners and writing the result to the given testImagePath\"\"\"\n        imageCopy = image.copy()\n        cv2.drawChessboardCorners(\n            imageCopy, self.pattern, self.corners, patternWasFound=True\n        )\n        if Corners.debugSorting:\n            index = 0\n            for point in self.topLeft, self.topRight, self.bottomRight, self.bottomLeft:\n                text = \"%d\" % (index)\n                x, y = point[0]\n                self.video.drawCenteredText(\n                    imageCopy, text, int(x), int(y), fontScale=1, fontBGRColor=(0, 0, 0)\n                )\n                index += 1\n        # if Corners.debugSorting:\n        #    for index,corner in enumerate(self.corners):\n        #        x,y=corner[0]\n        #        text=\"%d\" % (index)\n        #        self.video.drawCenteredText(imageCopy, text, int(x), int(y), fontScale=0.5,fontBGRColor=(128,128,128))\n        # cv2.imshow('corners', self.image)\n        # cv2.waitKey(50)\n        self.writeDebug(imageCopy, title, \"corners\")\n\n    def writeDebug(self, image, title, prefix):\n        Environment.checkDir(Environment.debugImagePath)\n        cv2.imwrite(\n            Environment.debugImagePath\n            + \"%s-%s-%dx%d.jpg\" % (title, prefix, self.rows, self.cols),\n            image,\n        )\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.debugSorting","title":"<code>debugSorting = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>pixel margin for masked polygons</p>"},{"location":"#pcwawc.boardfinder.Corners.__init__","title":"<code>__init__(pattern, video)</code>","text":"<p>initialize me with the given rows and columns</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def __init__(self, pattern, video):\n    \"\"\"initialize me with the given rows and columns\"\"\"\n    self.pattern = pattern\n    self.rows, self.cols = pattern\n    self.video = video\n    # prepare the dict for my polygons\n    self.polygons = {}\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.asPolygons","title":"<code>asPolygons(safetyMargin)</code>","text":"<p>get the polygons for my corner points</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def asPolygons(self, safetyMargin):\n    \"\"\"get the polygons for my corner points\"\"\"\n    # reshape the array\n    cps = np.reshape(self.corners, (self.cols, self.rows, 2))\n    polygons = {}\n    m = safetyMargin\n    for col in range(self.cols - 1):\n        for row in range(self.rows - 1):\n            x1, y1 = cps[col, row]  # top left\n            x2, y2 = cps[col + 1, row]  # left bottom\n            x3, y3 = cps[col + 1, row + 1]  # right bottom\n            x4, y4 = cps[col, row + 1]  # top right\n            clockwise = BoardFinder.sortPoints(\n                [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]\n            )\n            (x1, y1), (x2, y2), (x3, y3), (x4, y4) = clockwise\n            # https://stackoverflow.com/questions/19190484/what-is-the-opencv-findchessboardcorners-convention\n            polygon = np.array(\n                [\n                    self.safeXY(x1, y1, +m, +m),\n                    self.safeXY(x2, y2, -m, +m),\n                    self.safeXY(x3, y3, -m, -m),\n                    self.safeXY(x4, y4, +m, -m),\n                ],\n                dtype=np.int32,\n            )\n            polygons[(col, self.rows - 2 - row)] = polygon\n    return polygons\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.calcPolygons","title":"<code>calcPolygons(*safetyMargins)</code>","text":"<p>calculate polygons for the given safety margins</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def calcPolygons(self, *safetyMargins):\n    \"\"\"calculate polygons for the given safety margins\"\"\"\n    for safetyMargin in safetyMargins:\n        self.polygons[safetyMargin] = self.asPolygons(safetyMargin)\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.calcTrapez","title":"<code>calcTrapez()</code>","text":"<p>calculate the relevant quadrilaterals</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def calcTrapez(self):\n    \"\"\"calculate the relevant quadrilaterals\"\"\"\n    corners = self.corners\n    l = len(self.corners)\n    rowend = self.rows - 1\n    self.topLeft = corners[0]\n    self.topRight = corners[rowend]\n    self.bottomRight = corners[l - 1]\n    self.bottomLeft = corners[l - 1 - rowend]\n    self.trapez2Square = Trapez2Square(\n        self.topLeft, self.topRight, self.bottomRight, self.bottomLeft\n    )\n    self.trapez8x8 = self.trapezColRows(8, 8)\n    self.trapez10x10 = self.trapezColRows(10, 10)\n    self.trapez = self.trapez2Square.relativeTrapezToTrapezXY(0, 0, 1, 1)\n    pass\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.findPattern","title":"<code>findPattern(image)</code>","text":"<p>try finding the chess board corners in the given image with the given pattern</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def findPattern(self, image):\n    \"\"\"try finding the chess board corners in the given image with the given pattern\"\"\"\n    self.h, self.w = image.shape[:2]\n\n    start = timer()\n    ret, self.corners = cv2.findChessboardCorners(image, self.pattern, None)\n    end = timer()\n    if Corners.debug:\n        print(\n            \"%dx%d in %dx%d after %.3f s: %s\"\n            % (\n                self.rows,\n                self.cols,\n                self.w,\n                self.h,\n                (end - start),\n                \"\u2714\" if ret else \"\u274c\",\n            )\n        )\n    return ret\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.genChessPatterns","title":"<code>genChessPatterns()</code>  <code>staticmethod</code>","text":"<p>generate the patterns 7x7, 5x7, 3x7, 5x5, 5x3, 3x3</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>@staticmethod\ndef genChessPatterns():\n    \"\"\"generate the patterns 7x7, 5x7, 3x7, 5x5, 5x3, 3x3\"\"\"\n    for rows in range(7, 2, -2):\n        for cols in range(7, rows - 2, -2):\n            yield (rows, cols)\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.safeXY","title":"<code>safeXY(x, y, dx, dy)</code>","text":"<p>return the given x,y tuple shifted by dx,dy making sure the result is not out of my width and height bounds</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def safeXY(self, x, y, dx, dy):\n    \"\"\"return the given x,y tuple shifted by dx,dy making sure the result is not out of my width and height bounds\"\"\"\n    x = x + dx\n    y = y + dy\n    if y &gt;= self.h:\n        y = self.h - 1\n    if y &lt; 0:\n        y = 0\n    if x &gt;= self.w:\n        x = self.w - 1\n    if x &lt; 0:\n        x = 0\n    return (x, y)\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.showDebug","title":"<code>showDebug(image, title)</code>","text":"<p>'show' the debug picture of the chessboard corners by drawing the corners and writing the result to the given testImagePath</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def showDebug(self, image, title):\n    \"\"\"'show' the debug picture of the chessboard corners by drawing the corners and writing the result to the given testImagePath\"\"\"\n    imageCopy = image.copy()\n    cv2.drawChessboardCorners(\n        imageCopy, self.pattern, self.corners, patternWasFound=True\n    )\n    if Corners.debugSorting:\n        index = 0\n        for point in self.topLeft, self.topRight, self.bottomRight, self.bottomLeft:\n            text = \"%d\" % (index)\n            x, y = point[0]\n            self.video.drawCenteredText(\n                imageCopy, text, int(x), int(y), fontScale=1, fontBGRColor=(0, 0, 0)\n            )\n            index += 1\n    # if Corners.debugSorting:\n    #    for index,corner in enumerate(self.corners):\n    #        x,y=corner[0]\n    #        text=\"%d\" % (index)\n    #        self.video.drawCenteredText(imageCopy, text, int(x), int(y), fontScale=0.5,fontBGRColor=(128,128,128))\n    # cv2.imshow('corners', self.image)\n    # cv2.waitKey(50)\n    self.writeDebug(imageCopy, title, \"corners\")\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.showTrapezDebug","title":"<code>showTrapezDebug(image, title, corners)</code>","text":"<p>'show' a debug picture with the extrapolated quadrilaterals by writing an image to the debugImagePath</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def showTrapezDebug(self, image, title, corners):\n    \"\"\"'show' a debug picture with the extrapolated quadrilaterals by writing an image to the debugImagePath\"\"\"\n    overlay = image.copy()\n    # draw polytons from outer to inner\n    cv2.fillConvexPoly(overlay, self.trapez10x10, (0, 165, 255))  # orange\n    cv2.fillConvexPoly(overlay, self.trapez8x8, (128, 128, 128))  # grey\n    cv2.fillConvexPoly(overlay, self.trapez, (225, 105, 65))  # royal blue\n    alpha = 0.8  # Transparency factor.\n    # overlay the\n    imageAlpha = cv2.addWeighted(overlay, alpha, image, 1 - alpha, 0)\n    corners.writeDebug(imageAlpha, title, \"trapez\")\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.sort","title":"<code>sort()</code>","text":"<p>sort the corners - this step is currently not implemented so the corners stay rotated</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def sort(self):\n    \"\"\"sort the corners - this step is currently not implemented so the corners stay rotated\"\"\"\n    if Corners.debugSorting:\n        print(\"trying to sort %d points\" % (len(self.corners)))\n    cornerssorted = sorted(self.corners, key=Corners.sortXY)\n    if Corners.debugSorting:\n        print(cornerssorted)\n    # self.corners = np.empty(shape=(len(self.corners),2),dtype=np.float32)\n    # for i,val in enumerate(cornerssorted):\n    #    self.corners[i]=val\n    pass\n</code></pre>"},{"location":"#pcwawc.boardfinder.Corners.trapezColRows","title":"<code>trapezColRows(cols, rows)</code>","text":"<p>return an expanded trapez with the given number of columns and rows</p> Source code in <code>pcwawc/boardfinder.py</code> <pre><code>def trapezColRows(self, cols, rows):\n    \"\"\"return an expanded trapez with the given number of columns and rows\"\"\"\n    relDeltaRows = (rows / (self.rows - 1) - 1) / 2\n    relDeltaCols = (cols / (self.cols - 1) - 1) / 2\n    trapez = self.trapez2Square.relativeTrapezToTrapezXY(\n        -relDeltaRows, -relDeltaCols, 1 + relDeltaRows, 1 + relDeltaCols\n    )\n    return trapez\n</code></pre>"},{"location":"#pcwawc.chessengine","title":"<code>chessengine</code>","text":"<p>Created on 2019-12-16</p> <p>@author: wf</p>"},{"location":"#pcwawc.chessengine.Engine","title":"<code>Engine</code>","text":"<p>Chess Engines support e.g. Universal Chess Interface see https://chessprogramming.wikispaces.com/UCI</p> Source code in <code>pcwawc/chessengine.py</code> <pre><code>class Engine:\n    \"\"\"Chess Engines support e.g. Universal Chess Interface see https://chessprogramming.wikispaces.com/UCI\"\"\"\n\n    # shall we output debug information?\n    debug = False\n\n    # list of engines to search for\n    engineConfigs = [\n        {\n            \"name\": \"Crafty Computer Chess\",\n            \"command\": \"crafty\",\n            \"url\": \"http://www.craftychess.com/\",\n            \"protocol\": \"?\",\n        },\n        {\n            \"name\": \"GNU Chess\",\n            \"command\": \"gnuchess\",\n            \"url\": \"https://www.gnu.org/software/chess/\",\n            \"options\": \"--uci\",\n            \"protocol\": \"uci\",\n        },\n        {\n            \"name\": \"Stockfish Chess\",\n            \"command\": \"stockfish\",\n            \"url\": \"https://stockfishchess.org/\",\n            \"protocol\": \"uci\",\n        },\n        {\n            \"name\": \"XBoard\",\n            \"command\": \"xboard\",\n            \"url\": \"https://www.gnu.org/software/xboard/manual/xboard.html\",\n            \"protocol\": \"xboard\",\n        },\n    ]\n\n    def __init__(self, engineConfig, timeout=5):\n        \"\"\"\n        construct me with the given engineConfiguration and timeout\n\n        Args:\n            engineConfig(dict): the engine configuration to use\n            timeout(float): the number of seconds to wait of the given engine\n        \"\"\"\n        self.engineCmd = engineConfig[\"command\"]\n        self.enginePath = engineConfig[\"path\"]\n        self.name = engineConfig[\"name\"]\n        self.url = engineConfig[\"url\"]\n        self.protocolName = engineConfig[\"protocol\"]\n        self.options = engineConfig[\"options\"] if \"options\" in engineConfig else None\n        if self.protocolName == \"uci\":\n            self.protocol = chess.engine.UciProtocol\n        elif self.protocolName == \"xboard\":\n            self.protocol = chess.engine.XBoardProtocol\n        else:\n            self.protocol = None\n        self.timeout = timeout\n        # asyncio.set_event_loop_policy(chess.engine.EventLoopPolicy())\n        # https://python-chess.readthedocs.io/en/latest/engine.html\n        self.error = None\n\n    def open(self):\n        \"\"\"\n        open this chess engine\n        \"\"\"\n        self.engine = None\n        self.error = None\n        if self.protocol is None:\n            self.error = Exception(\"unknown protocol for %s\" % self.name)\n        else:\n            try:\n                cmd = [self.engineCmd]\n                if self.options:\n                    cmd.append(self.options)\n                self.engine = chess.engine.SimpleEngine.popen(\n                    self.protocol, cmd, timeout=self.timeout, debug=Engine.debug\n                )\n            except Exception as te:\n                self.error = te\n                pass\n        return self.engine\n\n    def close(self):\n        \"\"\"\n        close the given engine\n        \"\"\"\n        if self.engine is not None:\n            try:\n                self.engine.quit()\n            except concurrent.futures._base.TimeoutError:\n                # so what?\n                if self.debug:\n                    print(\n                        \"timeout after %1.f secs for %s on close forcing close now ...\"\n                        % (self.timeout, self.name)\n                    )\n                self.engine.close()\n                pass\n\n    def __str__(self):\n        text = \"chess engine %s called via %s at %s\" % (\n            self.name,\n            self.engineCmd,\n            self.enginePath,\n        )\n        return text\n\n    @staticmethod\n    def findEngines():\n        \"\"\"\n        check which engines from the Engine configurations are installed\n        on this computer and return a dict of these\n\n        Returns:\n            dict: map of Engines by Command e.g. \"gnuchess\" or \"stockfish\"\n        \"\"\"\n        engineDict = {}\n        for engineConfig in Engine.engineConfigs:\n            engineCmd = engineConfig[\"command\"]\n            enginePath = shutil.which(engineCmd)\n            if enginePath is not None:\n                if Engine.debug:\n                    print(\"found %s engine at %s\" % (engineCmd, enginePath))\n                engineConfig[\"path\"] = enginePath\n                engineDict[engineCmd] = engineConfig\n        return engineDict\n</code></pre>"},{"location":"#pcwawc.chessengine.Engine.__init__","title":"<code>__init__(engineConfig, timeout=5)</code>","text":"<p>construct me with the given engineConfiguration and timeout</p> <p>Parameters:</p> Name Type Description Default <code>engineConfig(dict)</code> <p>the engine configuration to use</p> required <code>timeout(float)</code> <p>the number of seconds to wait of the given engine</p> required Source code in <code>pcwawc/chessengine.py</code> <pre><code>def __init__(self, engineConfig, timeout=5):\n    \"\"\"\n    construct me with the given engineConfiguration and timeout\n\n    Args:\n        engineConfig(dict): the engine configuration to use\n        timeout(float): the number of seconds to wait of the given engine\n    \"\"\"\n    self.engineCmd = engineConfig[\"command\"]\n    self.enginePath = engineConfig[\"path\"]\n    self.name = engineConfig[\"name\"]\n    self.url = engineConfig[\"url\"]\n    self.protocolName = engineConfig[\"protocol\"]\n    self.options = engineConfig[\"options\"] if \"options\" in engineConfig else None\n    if self.protocolName == \"uci\":\n        self.protocol = chess.engine.UciProtocol\n    elif self.protocolName == \"xboard\":\n        self.protocol = chess.engine.XBoardProtocol\n    else:\n        self.protocol = None\n    self.timeout = timeout\n    # asyncio.set_event_loop_policy(chess.engine.EventLoopPolicy())\n    # https://python-chess.readthedocs.io/en/latest/engine.html\n    self.error = None\n</code></pre>"},{"location":"#pcwawc.chessengine.Engine.close","title":"<code>close()</code>","text":"<p>close the given engine</p> Source code in <code>pcwawc/chessengine.py</code> <pre><code>def close(self):\n    \"\"\"\n    close the given engine\n    \"\"\"\n    if self.engine is not None:\n        try:\n            self.engine.quit()\n        except concurrent.futures._base.TimeoutError:\n            # so what?\n            if self.debug:\n                print(\n                    \"timeout after %1.f secs for %s on close forcing close now ...\"\n                    % (self.timeout, self.name)\n                )\n            self.engine.close()\n            pass\n</code></pre>"},{"location":"#pcwawc.chessengine.Engine.findEngines","title":"<code>findEngines()</code>  <code>staticmethod</code>","text":"<p>check which engines from the Engine configurations are installed on this computer and return a dict of these</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>map of Engines by Command e.g. \"gnuchess\" or \"stockfish\"</p> Source code in <code>pcwawc/chessengine.py</code> <pre><code>@staticmethod\ndef findEngines():\n    \"\"\"\n    check which engines from the Engine configurations are installed\n    on this computer and return a dict of these\n\n    Returns:\n        dict: map of Engines by Command e.g. \"gnuchess\" or \"stockfish\"\n    \"\"\"\n    engineDict = {}\n    for engineConfig in Engine.engineConfigs:\n        engineCmd = engineConfig[\"command\"]\n        enginePath = shutil.which(engineCmd)\n        if enginePath is not None:\n            if Engine.debug:\n                print(\"found %s engine at %s\" % (engineCmd, enginePath))\n            engineConfig[\"path\"] = enginePath\n            engineDict[engineCmd] = engineConfig\n    return engineDict\n</code></pre>"},{"location":"#pcwawc.chessengine.Engine.open","title":"<code>open()</code>","text":"<p>open this chess engine</p> Source code in <code>pcwawc/chessengine.py</code> <pre><code>def open(self):\n    \"\"\"\n    open this chess engine\n    \"\"\"\n    self.engine = None\n    self.error = None\n    if self.protocol is None:\n        self.error = Exception(\"unknown protocol for %s\" % self.name)\n    else:\n        try:\n            cmd = [self.engineCmd]\n            if self.options:\n                cmd.append(self.options)\n            self.engine = chess.engine.SimpleEngine.popen(\n                self.protocol, cmd, timeout=self.timeout, debug=Engine.debug\n            )\n        except Exception as te:\n            self.error = te\n            pass\n    return self.engine\n</code></pre>"},{"location":"#pcwawc.chessimage","title":"<code>chessimage</code>","text":"<p>Created on 2019-12-10</p> <p>@author: wf</p>"},{"location":"#pcwawc.chessimage.ChessBoardImage","title":"<code>ChessBoardImage</code>","text":"<p>a chessboard image and it's transformations</p> Source code in <code>pcwawc/chessimage.py</code> <pre><code>@implementer(IChessBoardImage)\nclass ChessBoardImage:\n    \"\"\"a chessboard image and it's transformations\"\"\"\n\n    def __init__(self, image, title):\n        self.image = image\n        self.title = title\n        self.height, self.width = image.shape[:2]\n        self.pixels = self.height * self.width\n\n    def diffBoardImage(self, cbOther):\n        if cbOther is None:\n            raise Exception(\"other is None for diff\")\n        h, w = self.height, self.width\n        ho, wo = cbOther.height, cbOther.width\n        if not h == ho or not w == wo:\n            raise Exception(\n                \"image %d x %d has to have same size as other %d x %d for diff\"\n                % (w, h, wo, ho)\n            )\n        # return np.subtract(self.image,other)\n        diff = cv2.absdiff(self.image, cbOther.image)\n        return ChessBoardImage(diff, \"diff\")\n\n    def showDebug(self, video=None, keyWait=5):\n        if video is None:\n            video = Video()\n        video.showImage(self.image, self.title, keyWait=keyWait)\n</code></pre>"},{"location":"#pcwawc.chessimage.ChessBoardImageSet","title":"<code>ChessBoardImageSet</code>","text":"<p>a set of images of the current chess board</p> Source code in <code>pcwawc/chessimage.py</code> <pre><code>@implementer(IChessBoardImageSet)\nclass ChessBoardImageSet:\n    \"\"\"a set of images of the current chess board\"\"\"\n\n    def __init__(self, vision, image, frameIndex, timeStamp):\n        self.vision = vision\n        self.frameIndex = frameIndex\n        # see https://stackoverflow.com/questions/47743246/getting-timestamp-of-each-frame-in-a-video\n        self.timeStamp = timeStamp\n        self.cbImage = ChessBoardImage(image, \"chessboard\")\n        self.cbGUI = self.cbImage\n        self.cbWarped = None\n        self.cbIdeal = None\n        self.cbPreMove = None\n        self.cbDiff = None\n        self.cbDebug = None\n\n    def placeHolder(self, cbImage):\n        \"\"\"return an empty image if the image is not available\"\"\"\n        if cbImage is None:\n            return self.vision.video.createBlank(\n                self.cbWarped.width, self.cbWarped.height, (128, 128, 128)\n            )\n        else:\n            return cbImage.image\n\n    def debugImage(self):\n        if self.cbDebug is None:\n            self.cbDebug = self.debugImage2x2(\n                self.cbWarped, self.cbIdeal, self.cbDiff, self.cbPreMove\n            )\n        return self.cbDebug\n\n    def debugImage2x2(self, image1, image2, image3, image4):\n        image = self.vision.video.as2x2(\n            self.placeHolder(image1),\n            self.placeHolder(image2),\n            self.placeHolder(image3),\n            self.placeHolder(image4),\n        )\n        return ChessBoardImage(image, \"debug\")\n\n    def showDebug(self, video=None):\n        video.showImage(self.debugImage().image, \"debug\")\n\n    def warpAndRotate(self, nowarp=False):\n        \"\"\"warp and rotate the image as necessary - add timestamp if in debug mode\"\"\"\n        video = self.vision.video\n        warp = self.vision.warp\n        if warp.warping or nowarp:\n            if nowarp:\n                warped = self.cbImage.image.copy()\n            else:\n                warped = video.warp(self.cbImage.image, warp.points)\n            if warp.rotation &gt; 0:\n                warped = video.rotate(warped, warp.rotation)\n        else:\n            warped = self.cbImage.image.copy()\n        self.cbWarped = ChessBoardImage(warped, \"warped\")\n\n    def prepareGUI(self):\n        video = self.vision.video\n        warp = self.vision.warp\n        if self.vision.debug:\n            self.cbGUI = self.debugImage()\n            video.addTimeStamp(self.cbGUI.image)\n        else:\n            self.cbGUI = ChessBoardImage(self.cbWarped.image.copy(), \"gui\")\n            if not warp.warping:\n                video.drawTrapezoid(self.cbGUI.image, warp.points, warp.bgrColor)\n</code></pre>"},{"location":"#pcwawc.chessimage.ChessBoardImageSet.placeHolder","title":"<code>placeHolder(cbImage)</code>","text":"<p>return an empty image if the image is not available</p> Source code in <code>pcwawc/chessimage.py</code> <pre><code>def placeHolder(self, cbImage):\n    \"\"\"return an empty image if the image is not available\"\"\"\n    if cbImage is None:\n        return self.vision.video.createBlank(\n            self.cbWarped.width, self.cbWarped.height, (128, 128, 128)\n        )\n    else:\n        return cbImage.image\n</code></pre>"},{"location":"#pcwawc.chessimage.ChessBoardImageSet.warpAndRotate","title":"<code>warpAndRotate(nowarp=False)</code>","text":"<p>warp and rotate the image as necessary - add timestamp if in debug mode</p> Source code in <code>pcwawc/chessimage.py</code> <pre><code>def warpAndRotate(self, nowarp=False):\n    \"\"\"warp and rotate the image as necessary - add timestamp if in debug mode\"\"\"\n    video = self.vision.video\n    warp = self.vision.warp\n    if warp.warping or nowarp:\n        if nowarp:\n            warped = self.cbImage.image.copy()\n        else:\n            warped = video.warp(self.cbImage.image, warp.points)\n        if warp.rotation &gt; 0:\n            warped = video.rotate(warped, warp.rotation)\n    else:\n        warped = self.cbImage.image.copy()\n    self.cbWarped = ChessBoardImage(warped, \"warped\")\n</code></pre>"},{"location":"#pcwawc.chessimage.ChessBoardVision","title":"<code>ChessBoardVision</code>","text":"<p>               Bases: <code>JsonAbleMixin</code></p> <p>implements access to chessboard images</p> Source code in <code>pcwawc/chessimage.py</code> <pre><code>@implementer(IChessBoardVision)\nclass ChessBoardVision(JsonAbleMixin):\n    \"\"\"implements access to chessboard images\"\"\"\n\n    def __init__(self, args, board=None):\n        self.device = args.input\n        self.title = Video.title(self.device)\n        self.video = Video(self.title)\n        self.video.headless = Environment.inContinuousIntegration()\n        self.args = args\n        self.showDebug = args.debug\n        self.start = None\n        self.quitWanted = False\n        self.hasImage = False\n        self.timestamps = []\n        self.debug = args.debug\n        if board is None:\n            board = Board(args=args)\n        self.board = board\n        if self.args.fen is not None:\n            self.board.updatePieces(self.args.fen)\n        self.warp = Warp(args.warpPointList)\n        self.warp.rotation = args.rotation\n        if self.args.nowarp:\n            self.warp.warping = True\n        self.firstFrame = True\n        self.speedup = args.speedup\n        pass\n\n    def open(self, device):\n        self.video.capture(device)\n        self.device = device\n        self.firstFrame = True\n\n    def readChessBoardImage(self):\n        for i in range(self.speedup):\n            self.hasImage, image, self.quitWanted = self.video.readFrame(self.showDebug)\n            if self.quitWanted:\n                return self.previous\n        frames = self.video.frames\n        if self.firstFrame:\n            self.start = timer()\n        timestamp = timer() - self.start\n        self.chessBoardImageSet = ChessBoardImageSet(\n            self, image, frames // self.speedup, timestamp\n        )\n        self.firstFrame = False\n        self.timestamps.append(timestamp)\n        return self.chessBoardImageSet\n\n    def close(self):\n        self.video.close()\n\n    def __getstate__(self):\n        state = {}\n        state[\"title\"] = self.title\n        device = self.device\n        if not Video.is_int(device):\n            cwd = os.getcwd()\n            devicepath = os.path.dirname(device)\n            root = os.path.commonpath([cwd, devicepath])\n            device = os.path.relpath(devicepath, root) + \"/\" + os.path.basename(device)\n        state[\"device\"] = device\n        state[\"timestamps\"] = self.timestamps\n        return state\n\n    def __setstate__(self, state):\n        self.title = state[\"title\"]\n        self.device = state[\"device\"]\n        self.timestamps = state[\"timestamps\"]\n\n    def save(self, path=\"games/videos\"):\n        env = Environment()\n        savepath = str(env.projectPath) + \"/\" + path\n        Environment.checkDir(savepath)\n        jsonFile = savepath + \"/\" + self.title\n        self.writeJson(jsonFile)\n</code></pre>"},{"location":"#pcwawc.chessimage.Warp","title":"<code>Warp</code>","text":"<p>               Bases: <code>YamlAbleMixin</code>, <code>JsonAbleMixin</code></p> <p>holds the trapezoid points to be use for warping an image take from a peculiar angle</p> Source code in <code>pcwawc/chessimage.py</code> <pre><code>@implementer(IWarp)\nclass Warp(YamlAbleMixin, JsonAbleMixin):\n    \"\"\"holds the trapezoid points to be use for warping an image take from a peculiar angle\"\"\"\n\n    # construct me from the given setting\n    def __init__(self, pointList=[], rotation=0, bgrColor=(0, 255, 0)):\n        self.rotation = rotation\n        self.bgrColor = bgrColor\n        self.pointList = pointList\n        self.updatePoints()\n\n    def rotate(self, angle):\n        \"\"\"rotate me by the given angle\"\"\"\n        self.rotation = self.rotation + angle\n        if self.rotation &gt;= 360:\n            self.rotation = self.rotation % 360\n\n    def updatePoints(self):\n        \"\"\"update my points\"\"\"\n        pointLen = len(self.pointList)\n        if pointLen == 0:\n            self.points = None\n        else:\n            self.points = np.array(self.pointList)\n        self.warping = pointLen == 4\n\n    def addPoint(self, px, py):\n        \"\"\"add a point with the given px,py coordinate\n        to the warp points make sure we have a maximum of 4 warpPoints if warppoints are complete when adding reset them\n        this allows to support click UIs that need an unwarped image before setting new warp points.\n        px,py is irrelevant for reset\"\"\"\n        if len(self.pointList) &gt;= 4:\n            self.pointList = []\n        else:\n            self.pointList.append([px, py])\n        self.updatePoints()\n</code></pre>"},{"location":"#pcwawc.chessimage.Warp.addPoint","title":"<code>addPoint(px, py)</code>","text":"<p>add a point with the given px,py coordinate to the warp points make sure we have a maximum of 4 warpPoints if warppoints are complete when adding reset them this allows to support click UIs that need an unwarped image before setting new warp points. px,py is irrelevant for reset</p> Source code in <code>pcwawc/chessimage.py</code> <pre><code>def addPoint(self, px, py):\n    \"\"\"add a point with the given px,py coordinate\n    to the warp points make sure we have a maximum of 4 warpPoints if warppoints are complete when adding reset them\n    this allows to support click UIs that need an unwarped image before setting new warp points.\n    px,py is irrelevant for reset\"\"\"\n    if len(self.pointList) &gt;= 4:\n        self.pointList = []\n    else:\n        self.pointList.append([px, py])\n    self.updatePoints()\n</code></pre>"},{"location":"#pcwawc.chessimage.Warp.rotate","title":"<code>rotate(angle)</code>","text":"<p>rotate me by the given angle</p> Source code in <code>pcwawc/chessimage.py</code> <pre><code>def rotate(self, angle):\n    \"\"\"rotate me by the given angle\"\"\"\n    self.rotation = self.rotation + angle\n    if self.rotation &gt;= 360:\n        self.rotation = self.rotation % 360\n</code></pre>"},{"location":"#pcwawc.chessimage.Warp.updatePoints","title":"<code>updatePoints()</code>","text":"<p>update my points</p> Source code in <code>pcwawc/chessimage.py</code> <pre><code>def updatePoints(self):\n    \"\"\"update my points\"\"\"\n    pointLen = len(self.pointList)\n    if pointLen == 0:\n        self.points = None\n    else:\n        self.points = np.array(self.pointList)\n    self.warping = pointLen == 4\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid","title":"<code>chesstrapezoid</code>","text":""},{"location":"#pcwawc.chesstrapezoid.ChessTSquare","title":"<code>ChessTSquare</code>","text":"<p>a chess square in it's trapezoidal perspective</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>@implementer(ISquare)\nclass ChessTSquare:\n    \"\"\"a chess square in it's trapezoidal perspective\"\"\"\n\n    # relative position and size of original square\n    rw = 1 / (ChessTrapezoid.rows)\n    rh = 1 / (ChessTrapezoid.cols)\n\n    showDebugChange = []\n\n    def __init__(self, trapez, square):\n        \"\"\"construct me from the given trapez  and square\"\"\"\n        self.trapez = trapez\n        self.changeStats = MinMaxStats()\n        self.square = square\n        self.an = chess.SQUARE_NAMES[square]\n        # rank are rows in Algebraic Notation from 1 to 8\n        self.row = ChessTrapezoid.rows - 1 - chess.square_rank(square)\n        # files are columns in Algebraic Notation from A to H\n        self.col = chess.square_file(square)\n        # https://gamedev.stackexchange.com/a/44998/133453\n        self.fieldColor = chess.WHITE if (self.col + self.row) % 2 == 1 else chess.BLACK\n        self.fieldState = None\n        self.piece = None\n        self.preMoveImage = None\n        self.postMoveImage = None\n\n        self.rPieceRadius = ChessTSquare.rw / ChessTrapezoid.PieceRadiusFactor\n\n        self.rx, self.ry = self.col * ChessTSquare.rw, self.row * ChessTSquare.rh\n        self.rcx = self.rx + ChessTSquare.rw * 0.5\n        self.rcy = self.ry + ChessTSquare.rh * 0.5\n        self.x, self.y = trapez.relativeToTrapezXY(self.rx, self.ry)\n        self.setPolygons(\n            trapez,\n            self.rx,\n            self.ry,\n            self.rx + ChessTSquare.rw,\n            self.ry,\n            self.rx + ChessTSquare.rw,\n            self.ry + ChessTSquare.rh,\n            self.rx,\n            self.ry + ChessTSquare.rh,\n        )\n\n    def setPolygons(\n        self, trapez, rtl_x, rtl_y, rtr_x, rtr_y, rbr_x, rbr_y, rbl_x, rbl_y\n    ):\n        \"\"\"set my relative and warped polygons from the given relative corner coordinates from top left via top right, bottom right to bottom left\"\"\"\n        self.rpolygon = np.array(\n            [(rtl_x, rtl_y), (rtr_x, rtr_y), (rbr_x, rbr_y), (rbl_x, rbl_y)]\n        )\n        self.idealPolygon = (self.rpolygon * trapez.idealSize).astype(np.int32)\n        # function to use to calculate polygon\n        r2t = trapez.relativeToTrapezXY\n        self.polygon = np.array(\n            [r2t(rtl_x, rtl_y), r2t(rtr_x, rtr_y), r2t(rbr_x, rbr_y), r2t(rbl_x, rbl_y)]\n        )\n        self.ipolygon = self.polygon.astype(np.int32)\n\n    def getPolygon(self, transformation):\n        if transformation == Transformation.ORIGINAL:\n            return self.ipolygon\n        elif transformation == Transformation.RELATIVE:\n            return self.rpolygon\n        elif transformation == Transformation.IDEAL:\n            return self.idealPolygon\n        else:\n            raise Exception(\"invalid transformation %d for getPolygon\", transformation)\n\n    def getFieldState(self):\n        piece = self.piece\n        if piece is None:\n            if self.fieldColor == chess.WHITE:\n                return FieldState.WHITE_EMPTY\n            else:\n                return FieldState.BLACK_EMPTY\n        elif piece.color == chess.WHITE:\n            if self.fieldColor == chess.WHITE:\n                return FieldState.WHITE_WHITE\n            else:\n                return FieldState.BLACK_WHITE\n        else:\n            if self.fieldColor == chess.WHITE:\n                return FieldState.WHITE_BLACK\n            else:\n                return FieldState.BLACK_BLACK\n        # this can't happen\n        return None\n\n    def drawState(self, image, transformation, channels):\n        \"\"\"draw my state onto the given image with the given transformation and number of channels\"\"\"\n        # default is drawing a single channel mask\n        squareImageColor = 64\n        pieceImageColor = squareImageColor\n        if channels == 3:\n            if self.fieldColor == chess.WHITE:\n                if FieldState.WHITE_EMPTY in self.trapez.averageColors:\n                    squareImageColor = self.trapez.averageColors[\n                        FieldState.WHITE_EMPTY\n                    ].color\n                else:\n                    squareImageColor = Color.white\n            else:\n                if FieldState.BLACK_EMPTY in self.trapez.averageColors:\n                    squareImageColor = self.trapez.averageColors[\n                        FieldState.BLACK_EMPTY\n                    ].color\n                else:\n                    squareImageColor = Color.black\n\n        if not (channels == 1 and self.piece is not None):\n            self.trapez.video.drawPolygon(\n                image, self.getPolygon(transformation), squareImageColor\n            )\n\n        if self.piece is not None:\n            if channels == 3:\n                if self.fieldState in self.trapez.averageColors:\n                    pieceImageColor = self.trapez.averageColors[self.fieldState].color\n                else:\n                    pieceImageColor = (\n                        Color.darkgrey\n                        if self.piece.color == chess.BLACK\n                        else Color.lightgrey\n                    )\n            rcenter = self.rcenter()\n            self.trapez.drawRCircle(image, rcenter, self.rPieceRadius, pieceImageColor)\n\n    def rcenter(self):\n        rcx = self.rx + ChessTSquare.rw / 2\n        rcy = self.ry + ChessTSquare.rh / 2\n        return (rcx, rcy)\n\n    def rxy2xy(self, image):\n        h, w = image.shape[:2]\n        x = int(self.rx * w)\n        y = int(self.ry * h)\n        dh = h // ChessTrapezoid.rows\n        dw = w // ChessTrapezoid.cols\n        return h, w, x, y, dh, dw\n\n    def addPreMoveImage(self, image):\n        if self.preMoveImage is not None:\n            h, w, x, y, dh, dw = self.rxy2xy(image)\n            np.copyto(image[y : y + dh, x : x + dw], self.preMoveImage)\n\n    def drawDebug(self, image, color=(255, 255, 255)):\n        \"\"\"draw debug information onto the given image using the given color\"\"\"\n        symbol = \"\"\n        if self.piece is not None:\n            symbol = (\n                self.piece.symbol()\n            )  # @TODO piece.unicode_symbol() - needs other font!\n        squareHint = self.an + \" \" + symbol\n        rcx, rcy = self.rcenter()\n        self.trapez.drawRCenteredText(image, squareHint, rcx, rcy, color=color)\n\n    def getSquareImage(self, cbImage):\n        \"\"\"get the image of me within the given image\"\"\"\n        h, w, x, y, dh, dw = self.rxy2xy(cbImage.image)\n        squareImage = cbImage.image[y : y + dh, x : x + dw]\n        return squareImage\n\n    def squareChange(self, image, diffImage):\n        \"\"\"check the changes analyzing the difference image of this square\"\"\"\n        h, w, x, y, dh, dw = self.rxy2xy(image)\n\n        self.squareImage = image[y : y + dh, x : x + dw]\n        self.diffImage = diffImage[y : y + dh, x : x + dw]\n        diffSum = np.sum(self.diffImage)\n        # the value is 64 times lower then the per pixel value\n        self.currentChange = SquareChange(diffSum / (h * w), self.changeStats)\n        return self.currentChange\n\n    def checkMoved(self, detectState):\n        \"\"\"check a figure has been moved, so that the state of this square has changed\"\"\"\n        squareChange = self.currentChange\n        # if the whole board is valid\n        if detectState.validBoard:\n            # if we come from an stable invalid period then this is likely a move\n            if detectState.invalidStable and self.preMoveImage is not None:\n                if not squareChange.valid:\n                    self.postMoveImage = self.squareImage\n                    if detectState.onPieceMoveDetected is not None:\n                        detectState.onPieceMoveDetected(self)\n                    self.changeStats.clear()\n                    self.preMoveImage = None\n\n            detectState.invalidEnd()\n            # add the current change statistics to my statistics\n            squareChange.push(self.changeStats, squareChange.value)\n            # if we have been valid for a long enough period of time\n            if detectState.validStable:\n                # remember my image - we are ready to detect a move\n                self.preMoveImage = self.squareImage\n                pass\n        else:\n            if detectState.invalidStarted:\n                detectState.validEnd()\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTSquare.__init__","title":"<code>__init__(trapez, square)</code>","text":"<p>construct me from the given trapez  and square</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def __init__(self, trapez, square):\n    \"\"\"construct me from the given trapez  and square\"\"\"\n    self.trapez = trapez\n    self.changeStats = MinMaxStats()\n    self.square = square\n    self.an = chess.SQUARE_NAMES[square]\n    # rank are rows in Algebraic Notation from 1 to 8\n    self.row = ChessTrapezoid.rows - 1 - chess.square_rank(square)\n    # files are columns in Algebraic Notation from A to H\n    self.col = chess.square_file(square)\n    # https://gamedev.stackexchange.com/a/44998/133453\n    self.fieldColor = chess.WHITE if (self.col + self.row) % 2 == 1 else chess.BLACK\n    self.fieldState = None\n    self.piece = None\n    self.preMoveImage = None\n    self.postMoveImage = None\n\n    self.rPieceRadius = ChessTSquare.rw / ChessTrapezoid.PieceRadiusFactor\n\n    self.rx, self.ry = self.col * ChessTSquare.rw, self.row * ChessTSquare.rh\n    self.rcx = self.rx + ChessTSquare.rw * 0.5\n    self.rcy = self.ry + ChessTSquare.rh * 0.5\n    self.x, self.y = trapez.relativeToTrapezXY(self.rx, self.ry)\n    self.setPolygons(\n        trapez,\n        self.rx,\n        self.ry,\n        self.rx + ChessTSquare.rw,\n        self.ry,\n        self.rx + ChessTSquare.rw,\n        self.ry + ChessTSquare.rh,\n        self.rx,\n        self.ry + ChessTSquare.rh,\n    )\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTSquare.checkMoved","title":"<code>checkMoved(detectState)</code>","text":"<p>check a figure has been moved, so that the state of this square has changed</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def checkMoved(self, detectState):\n    \"\"\"check a figure has been moved, so that the state of this square has changed\"\"\"\n    squareChange = self.currentChange\n    # if the whole board is valid\n    if detectState.validBoard:\n        # if we come from an stable invalid period then this is likely a move\n        if detectState.invalidStable and self.preMoveImage is not None:\n            if not squareChange.valid:\n                self.postMoveImage = self.squareImage\n                if detectState.onPieceMoveDetected is not None:\n                    detectState.onPieceMoveDetected(self)\n                self.changeStats.clear()\n                self.preMoveImage = None\n\n        detectState.invalidEnd()\n        # add the current change statistics to my statistics\n        squareChange.push(self.changeStats, squareChange.value)\n        # if we have been valid for a long enough period of time\n        if detectState.validStable:\n            # remember my image - we are ready to detect a move\n            self.preMoveImage = self.squareImage\n            pass\n    else:\n        if detectState.invalidStarted:\n            detectState.validEnd()\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTSquare.drawDebug","title":"<code>drawDebug(image, color=(255, 255, 255))</code>","text":"<p>draw debug information onto the given image using the given color</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def drawDebug(self, image, color=(255, 255, 255)):\n    \"\"\"draw debug information onto the given image using the given color\"\"\"\n    symbol = \"\"\n    if self.piece is not None:\n        symbol = (\n            self.piece.symbol()\n        )  # @TODO piece.unicode_symbol() - needs other font!\n    squareHint = self.an + \" \" + symbol\n    rcx, rcy = self.rcenter()\n    self.trapez.drawRCenteredText(image, squareHint, rcx, rcy, color=color)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTSquare.drawState","title":"<code>drawState(image, transformation, channels)</code>","text":"<p>draw my state onto the given image with the given transformation and number of channels</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def drawState(self, image, transformation, channels):\n    \"\"\"draw my state onto the given image with the given transformation and number of channels\"\"\"\n    # default is drawing a single channel mask\n    squareImageColor = 64\n    pieceImageColor = squareImageColor\n    if channels == 3:\n        if self.fieldColor == chess.WHITE:\n            if FieldState.WHITE_EMPTY in self.trapez.averageColors:\n                squareImageColor = self.trapez.averageColors[\n                    FieldState.WHITE_EMPTY\n                ].color\n            else:\n                squareImageColor = Color.white\n        else:\n            if FieldState.BLACK_EMPTY in self.trapez.averageColors:\n                squareImageColor = self.trapez.averageColors[\n                    FieldState.BLACK_EMPTY\n                ].color\n            else:\n                squareImageColor = Color.black\n\n    if not (channels == 1 and self.piece is not None):\n        self.trapez.video.drawPolygon(\n            image, self.getPolygon(transformation), squareImageColor\n        )\n\n    if self.piece is not None:\n        if channels == 3:\n            if self.fieldState in self.trapez.averageColors:\n                pieceImageColor = self.trapez.averageColors[self.fieldState].color\n            else:\n                pieceImageColor = (\n                    Color.darkgrey\n                    if self.piece.color == chess.BLACK\n                    else Color.lightgrey\n                )\n        rcenter = self.rcenter()\n        self.trapez.drawRCircle(image, rcenter, self.rPieceRadius, pieceImageColor)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTSquare.getSquareImage","title":"<code>getSquareImage(cbImage)</code>","text":"<p>get the image of me within the given image</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def getSquareImage(self, cbImage):\n    \"\"\"get the image of me within the given image\"\"\"\n    h, w, x, y, dh, dw = self.rxy2xy(cbImage.image)\n    squareImage = cbImage.image[y : y + dh, x : x + dw]\n    return squareImage\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTSquare.setPolygons","title":"<code>setPolygons(trapez, rtl_x, rtl_y, rtr_x, rtr_y, rbr_x, rbr_y, rbl_x, rbl_y)</code>","text":"<p>set my relative and warped polygons from the given relative corner coordinates from top left via top right, bottom right to bottom left</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def setPolygons(\n    self, trapez, rtl_x, rtl_y, rtr_x, rtr_y, rbr_x, rbr_y, rbl_x, rbl_y\n):\n    \"\"\"set my relative and warped polygons from the given relative corner coordinates from top left via top right, bottom right to bottom left\"\"\"\n    self.rpolygon = np.array(\n        [(rtl_x, rtl_y), (rtr_x, rtr_y), (rbr_x, rbr_y), (rbl_x, rbl_y)]\n    )\n    self.idealPolygon = (self.rpolygon * trapez.idealSize).astype(np.int32)\n    # function to use to calculate polygon\n    r2t = trapez.relativeToTrapezXY\n    self.polygon = np.array(\n        [r2t(rtl_x, rtl_y), r2t(rtr_x, rtr_y), r2t(rbr_x, rbr_y), r2t(rbl_x, rbl_y)]\n    )\n    self.ipolygon = self.polygon.astype(np.int32)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTSquare.squareChange","title":"<code>squareChange(image, diffImage)</code>","text":"<p>check the changes analyzing the difference image of this square</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def squareChange(self, image, diffImage):\n    \"\"\"check the changes analyzing the difference image of this square\"\"\"\n    h, w, x, y, dh, dw = self.rxy2xy(image)\n\n    self.squareImage = image[y : y + dh, x : x + dw]\n    self.diffImage = diffImage[y : y + dh, x : x + dw]\n    diffSum = np.sum(self.diffImage)\n    # the value is 64 times lower then the per pixel value\n    self.currentChange = SquareChange(diffSum / (h * w), self.changeStats)\n    return self.currentChange\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid","title":"<code>ChessTrapezoid</code>","text":"<p>               Bases: <code>Trapez2Square</code></p> <p>Chess board Trapezoid (UK) / Trapezium (US) / Trapez (DE)  as seen via a webcam image</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>class ChessTrapezoid(Trapez2Square):\n    \"\"\"Chess board Trapezoid (UK) / Trapezium (US) / Trapez (DE)  as seen via a webcam image\"\"\"\n\n    debug = False\n    colorDebug = False\n    showDebugImage = False\n    rows = 8\n    cols = 8\n    # default radius of pieces\n    PieceRadiusFactor = 3\n    DiffSumMovingAverageLength = 5\n\n    def __init__(self, trapezPoints, idealSize=640, rotation=0, video=None):\n        self.rotation = rotation\n        # trapezPoints=[topLeft,topRight,bottomRight,bottomLeft]\n        shifts = self.rotation // 90\n        for shift in range(shifts):\n            left = trapezPoints.pop(0)\n            trapezPoints.append(left)\n        topLeft, topRight, bottomRight, bottomLeft = trapezPoints\n        super().__init__(topLeft, topRight, bottomRight, bottomLeft)\n        self.setup(idealSize, video)\n\n    def setup(self, idealSize=640, video=None):\n        # video access (for debugging and partly hiding open cv details)\n        if video is None:\n            self.video = Video()\n        self.idealSize = idealSize\n        s = idealSize\n        self.pts_IdealSquare = np.asarray(\n            [[0.0, 0.0], [s, 0.0], [s, s], [0.0, s]], dtype=np.float32\n        )\n        self.inverseTransform = cv2.getPerspectiveTransform(\n            self.pts_dst, self.pts_IdealSquare\n        )\n        self.rotation = 0\n        # dict for average Colors\n        self.averageColors = {}\n        self.diffSumAverage = MovingAverage(ChessTrapezoid.DiffSumMovingAverageLength)\n        # trapezoid representation of squares\n        self.tsquares = {}\n        for square in chess.SQUARES:\n            tsquare = ChessTSquare(self, square)\n            if ChessTrapezoid.debug:\n                print(vars(tsquare))\n            self.tsquares[tsquare.square] = tsquare\n\n    def relativeToIdealXY(self, rx, ry):\n        x = int(rx * self.idealSize)\n        y = int(ry * self.idealSize)\n        return x, y\n\n    def tSquareAt(self, row, col, rotation=0):\n        \"\"\"get the trapezoid chessboard square for the given row and column\"\"\"\n        row, col = self.rotateIndices(row, col, rotation)\n        squareIndex = (ChessTrapezoid.rows - 1 - row) * ChessTrapezoid.cols + col\n        square = chess.SQUARES[squareIndex]\n        return self.tsquares[square]\n\n    def rotateIndices(self, row, col, rotation):\n        \"\"\"rotate the indices or rows and columns according to the board rotation\"\"\"\n        if rotation == 0:\n            return row, col\n        elif rotation == 90:\n            return ChessTrapezoid.cols - 1 - col, row\n        elif rotation == 180:\n            return ChessTrapezoid.rows - 1 - row, ChessTrapezoid.cols - 1 - col\n        elif rotation == 270:\n            return col, ChessTrapezoid.rows - 1 - row\n        else:\n            raise Exception(\"invalid rotation %d for rotateIndices\" % rotation)\n\n    def genSquares(self):\n        \"\"\"generator for all chess squares\"\"\"\n        for square in chess.SQUARES:\n            tsquare = self.tsquares[square]\n            yield tsquare\n\n    def drawCircle(self, image, center, radius, color, thickness=-1):\n        \"\"\"draw a circle onto the given image at the given center point with the given radius, color and thickness.\"\"\"\n        if color is not None:\n            cv2.circle(image, center, radius, color=color, thickness=thickness)\n\n    def drawRCircle(self, image, rcenter, rradius, color, thickness=-1):\n        \"\"\"draw a circle with relative coordinates\"\"\"\n        radius = int(rradius * self.idealSize)\n        rx, ry = rcenter\n        center = self.relativeToIdealXY(rx, ry)\n        self.drawCircle(image, center, radius, color, thickness)\n\n    def drawRCenteredText(self, image, text, rx, ry, color=(255, 255, 255)):\n        x, y = self.relativeToIdealXY(rx, ry)\n        self.video.drawCenteredText(image, text, x, y, fontBGRColor=color)\n\n    def updatePieces(self, fen):\n        \"\"\"update the piece positions according to the given FEN\"\"\"\n        self.board = chess.Board(fen)\n        for tsquare in self.genSquares():\n            piece = self.board.piece_at(tsquare.square)\n            tsquare.piece = piece\n            tsquare.fieldState = tsquare.getFieldState()\n\n    def drawFieldStates(\n        self, image, fieldStates, transformation=Transformation.ORIGINAL, channels=3\n    ):\n        \"\"\"draw the states for fields with the given field states e.g. to set the mask image that will filter the trapezoid view according to piece positions when using maskImage\"\"\"\n        if self.board is not None:\n            for tsquare in self.genSquares():\n                if tsquare.fieldState in fieldStates:\n                    tsquare.drawState(image, transformation, channels)\n\n    def prepareImageSet(self, cbImageSet):\n        \"\"\"prepare the image set\"\"\"\n        cbWarped = self.warpedBoardImage(cbImageSet.cbImage.image)\n        averageColors = self.analyzeColors(cbWarped)\n        cbImageSet.cbWarped = cbWarped\n        cbIdeal = self.idealColoredBoard(cbWarped.width, cbWarped.height)\n        cbImageSet.cbIdeal = cbIdeal\n        cbImageSet.cbPreMove = self.preMoveBoard(cbWarped.width, cbWarped.height)\n        cbImageSet.cbDiff = cbWarped.diffBoardImage(cbIdeal)\n        return averageColors\n\n    def warpedBoardImage(self, image):\n        warped = cv2.warpPerspective(\n            image, self.inverseTransform, (self.idealSize, self.idealSize)\n        )\n        return ChessBoardImage(warped, \"warped\")\n\n    def diffSum(self, image, other):\n        # diffImage=self.diff(other)\n        # return diffImage.sum()\n        # https://stackoverflow.com/questions/17829092/opencv-cv2-absdiffimg1-img2-sum-without-temporary-img\n        diffSumValue = cv2.norm(image, other, cv2.NORM_L1)\n        if ChessTrapezoid.debug:\n            print(\"diffSum %.0f\" % (diffSumValue))\n        return diffSumValue\n\n    def idealColoredBoard(self, w, h, transformation=Transformation.IDEAL):\n        \"\"\"draw an 'ideal' colored board according to a given set of parameters e.g. fieldColor, pieceColor, pieceRadius\"\"\"\n        idealImage = self.video.getEmptyImage4WidthAndHeight(w, h, 3)\n        for tsquare in self.genSquares():\n            tsquare.drawState(idealImage, transformation, 3)\n        return ChessBoardImage(idealImage, \"ideal\")\n\n    def preMoveBoard(self, w, h):\n        \"\"\"get an image of the board as it was before any move\"\"\"\n        refImage = self.video.getEmptyImage4WidthAndHeight(w, h, 3)\n        for tsquare in self.genSquares():\n            tsquare.addPreMoveImage(refImage)\n        return ChessBoardImage(refImage, \"preMove ref\")\n\n    def drawDebug(self, image, color=(255, 255, 255)):\n        \"\"\"draw debug information e.g. piecel symbol and an onto the given image\"\"\"\n        for square in chess.SQUARES:\n            tsquare = self.tsquares[square]\n            tsquare.drawDebug(image, color)\n\n    def byFieldState(self):\n        # get a dict of fields sorted by field state\n        sortedTSquares = {}\n        for fieldState in FieldState:\n            sortedTSquares[fieldState] = []\n        for tsquare in self.genSquares():\n            sortedTSquares[tsquare.fieldState].append(tsquare)\n        return sortedTSquares\n\n    def analyzeColors(self, cbImage):\n        \"\"\"get the average colors per fieldState\"\"\"\n        byFieldState = self.byFieldState()\n        for fieldState in byFieldState.keys():\n            mask = self.video.getEmptyImage(cbImage.image)\n            self.drawFieldStates(mask, [fieldState], Transformation.IDEAL, 1)\n            masked = self.video.maskImage(cbImage.image, mask)\n            countedFields = len(byFieldState[fieldState])\n            averageColor = Color(masked)\n            self.averageColors[fieldState] = averageColor\n            if ChessTrapezoid.showDebugImage:\n                self.video.showImage(masked, fieldState.title())\n            if ChessTrapezoid.colorDebug:\n                print(\n                    \"%15s (%2d): %s\" % (fieldState.title(), countedFields, averageColor)\n                )\n        return self.averageColors\n\n    def optimizeColorCheck(self, cbImage, averageColors, debug=False):\n        optimalSelectivity = -100\n        colorStats = None\n        for factor in [x * 0.05 for x in range(20, 41)]:\n            \"\"\"optimize the factor for the color check\"\"\"\n            startc = timer()\n            fieldColorStatsCandidate = self.checkColors(cbImage, averageColors, factor)\n            endc = timer()\n            fieldColorStatsCandidate.analyzeStats(factor, endc - startc)\n            if fieldColorStatsCandidate.minSelectivity &gt; optimalSelectivity:\n                optimalSelectivity = fieldColorStatsCandidate.minSelectivity\n                colorStats = fieldColorStatsCandidate\n                if debug:\n                    print(\n                        \"selectivity %5.1f white: %5.1f black: %5.1f \"\n                        % (\n                            self.minSelectivity,\n                            self.whiteSelectivity,\n                            self.blackSelectivity,\n                        )\n                    )\n        return colorStats\n\n    def checkColors(self, cbImage, averageColors, rangeFactor=1.0):\n        \"\"\"check the colors against the expectation\"\"\"\n        byFieldState = self.byFieldState()\n        colorStats = FieldColorStats()\n        for fieldState in byFieldState.keys():\n            # https://stackoverflow.com/questions/54019108/how-to-count-the-pixels-of-a-certain-color-with-opencv\n            if fieldState in [\n                FieldState.WHITE_BLACK,\n                FieldState.WHITE_EMPTY,\n                FieldState.WHITE_WHITE,\n            ]:\n                averageColor = averageColors[FieldState.WHITE_EMPTY]\n            else:\n                averageColor = averageColors[FieldState.BLACK_EMPTY]\n            fields = byFieldState[fieldState]\n            lower, upper = averageColor.colorRange(rangeFactor)\n            if ChessTrapezoid.colorDebug:\n                print(\n                    \"%25s (%2d): %s -&gt; %s - %s\"\n                    % (fieldState.title(), len(fields), averageColor, lower, upper)\n                )\n            for tsquare in fields:\n                squareImage = tsquare.getSquareImage(cbImage)\n                asExpected = cv2.inRange(squareImage, lower, upper)\n                h, w = squareImage.shape[:2]\n                pixels = h * w\n                nonzero = cv2.countNonZero(asExpected)\n                colorStats.push(fieldState, tsquare.an, nonzero / pixels * 100)\n                # self.video.showImage(asExpected,tsquare.an)\n        return colorStats\n\n    def detectChanges(self, cbImageSet, detectState):\n        \"\"\"detect the changes of the given imageset using the given detect state machine\"\"\"\n        detectState.nextFrame()\n        changes = {}\n        validChanges = 0\n        diffSum = 0\n        cbImage = cbImageSet.cbImage\n        cbDiff = cbImageSet.cbDiff\n        for tsquare in self.genSquares():\n            squareChange = tsquare.squareChange(cbImage.image, cbDiff.image)\n            changes[tsquare.an] = squareChange\n            diffSum += abs(squareChange.diff)\n            if squareChange.valid:\n                validChanges += 1\n            # if self.frames==1:\n            #    tsquare.preMoveImage=np.copy(tsquare.squareImage)\n\n        self.diffSumAverage.push(diffSum)\n        diffSumDelta = self.diffSumAverage.mean() - diffSum\n        detectState.check(\n            validChanges, diffSum, diffSumDelta, squareChange.meanFrameCount\n        )\n        for tsquare in self.genSquares():\n            squareChange = changes[tsquare.an]\n            tsquare.checkMoved(detectState)\n\n        changes[\"validBoard\"] = detectState.validBoard\n        changes[\"valid\"] = validChanges\n        changes[\"diffSum\"] = diffSum\n        changes[\"diffSumDelta\"] = diffSumDelta\n        changes[\"validFrames\"] = detectState.validFrames\n        changes[\"invalidFrames\"] = detectState.invalidFrames\n        return changes\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.analyzeColors","title":"<code>analyzeColors(cbImage)</code>","text":"<p>get the average colors per fieldState</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def analyzeColors(self, cbImage):\n    \"\"\"get the average colors per fieldState\"\"\"\n    byFieldState = self.byFieldState()\n    for fieldState in byFieldState.keys():\n        mask = self.video.getEmptyImage(cbImage.image)\n        self.drawFieldStates(mask, [fieldState], Transformation.IDEAL, 1)\n        masked = self.video.maskImage(cbImage.image, mask)\n        countedFields = len(byFieldState[fieldState])\n        averageColor = Color(masked)\n        self.averageColors[fieldState] = averageColor\n        if ChessTrapezoid.showDebugImage:\n            self.video.showImage(masked, fieldState.title())\n        if ChessTrapezoid.colorDebug:\n            print(\n                \"%15s (%2d): %s\" % (fieldState.title(), countedFields, averageColor)\n            )\n    return self.averageColors\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.checkColors","title":"<code>checkColors(cbImage, averageColors, rangeFactor=1.0)</code>","text":"<p>check the colors against the expectation</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def checkColors(self, cbImage, averageColors, rangeFactor=1.0):\n    \"\"\"check the colors against the expectation\"\"\"\n    byFieldState = self.byFieldState()\n    colorStats = FieldColorStats()\n    for fieldState in byFieldState.keys():\n        # https://stackoverflow.com/questions/54019108/how-to-count-the-pixels-of-a-certain-color-with-opencv\n        if fieldState in [\n            FieldState.WHITE_BLACK,\n            FieldState.WHITE_EMPTY,\n            FieldState.WHITE_WHITE,\n        ]:\n            averageColor = averageColors[FieldState.WHITE_EMPTY]\n        else:\n            averageColor = averageColors[FieldState.BLACK_EMPTY]\n        fields = byFieldState[fieldState]\n        lower, upper = averageColor.colorRange(rangeFactor)\n        if ChessTrapezoid.colorDebug:\n            print(\n                \"%25s (%2d): %s -&gt; %s - %s\"\n                % (fieldState.title(), len(fields), averageColor, lower, upper)\n            )\n        for tsquare in fields:\n            squareImage = tsquare.getSquareImage(cbImage)\n            asExpected = cv2.inRange(squareImage, lower, upper)\n            h, w = squareImage.shape[:2]\n            pixels = h * w\n            nonzero = cv2.countNonZero(asExpected)\n            colorStats.push(fieldState, tsquare.an, nonzero / pixels * 100)\n            # self.video.showImage(asExpected,tsquare.an)\n    return colorStats\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.detectChanges","title":"<code>detectChanges(cbImageSet, detectState)</code>","text":"<p>detect the changes of the given imageset using the given detect state machine</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def detectChanges(self, cbImageSet, detectState):\n    \"\"\"detect the changes of the given imageset using the given detect state machine\"\"\"\n    detectState.nextFrame()\n    changes = {}\n    validChanges = 0\n    diffSum = 0\n    cbImage = cbImageSet.cbImage\n    cbDiff = cbImageSet.cbDiff\n    for tsquare in self.genSquares():\n        squareChange = tsquare.squareChange(cbImage.image, cbDiff.image)\n        changes[tsquare.an] = squareChange\n        diffSum += abs(squareChange.diff)\n        if squareChange.valid:\n            validChanges += 1\n        # if self.frames==1:\n        #    tsquare.preMoveImage=np.copy(tsquare.squareImage)\n\n    self.diffSumAverage.push(diffSum)\n    diffSumDelta = self.diffSumAverage.mean() - diffSum\n    detectState.check(\n        validChanges, diffSum, diffSumDelta, squareChange.meanFrameCount\n    )\n    for tsquare in self.genSquares():\n        squareChange = changes[tsquare.an]\n        tsquare.checkMoved(detectState)\n\n    changes[\"validBoard\"] = detectState.validBoard\n    changes[\"valid\"] = validChanges\n    changes[\"diffSum\"] = diffSum\n    changes[\"diffSumDelta\"] = diffSumDelta\n    changes[\"validFrames\"] = detectState.validFrames\n    changes[\"invalidFrames\"] = detectState.invalidFrames\n    return changes\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.drawCircle","title":"<code>drawCircle(image, center, radius, color, thickness=-1)</code>","text":"<p>draw a circle onto the given image at the given center point with the given radius, color and thickness.</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def drawCircle(self, image, center, radius, color, thickness=-1):\n    \"\"\"draw a circle onto the given image at the given center point with the given radius, color and thickness.\"\"\"\n    if color is not None:\n        cv2.circle(image, center, radius, color=color, thickness=thickness)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.drawDebug","title":"<code>drawDebug(image, color=(255, 255, 255))</code>","text":"<p>draw debug information e.g. piecel symbol and an onto the given image</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def drawDebug(self, image, color=(255, 255, 255)):\n    \"\"\"draw debug information e.g. piecel symbol and an onto the given image\"\"\"\n    for square in chess.SQUARES:\n        tsquare = self.tsquares[square]\n        tsquare.drawDebug(image, color)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.drawFieldStates","title":"<code>drawFieldStates(image, fieldStates, transformation=Transformation.ORIGINAL, channels=3)</code>","text":"<p>draw the states for fields with the given field states e.g. to set the mask image that will filter the trapezoid view according to piece positions when using maskImage</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def drawFieldStates(\n    self, image, fieldStates, transformation=Transformation.ORIGINAL, channels=3\n):\n    \"\"\"draw the states for fields with the given field states e.g. to set the mask image that will filter the trapezoid view according to piece positions when using maskImage\"\"\"\n    if self.board is not None:\n        for tsquare in self.genSquares():\n            if tsquare.fieldState in fieldStates:\n                tsquare.drawState(image, transformation, channels)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.drawRCircle","title":"<code>drawRCircle(image, rcenter, rradius, color, thickness=-1)</code>","text":"<p>draw a circle with relative coordinates</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def drawRCircle(self, image, rcenter, rradius, color, thickness=-1):\n    \"\"\"draw a circle with relative coordinates\"\"\"\n    radius = int(rradius * self.idealSize)\n    rx, ry = rcenter\n    center = self.relativeToIdealXY(rx, ry)\n    self.drawCircle(image, center, radius, color, thickness)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.genSquares","title":"<code>genSquares()</code>","text":"<p>generator for all chess squares</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def genSquares(self):\n    \"\"\"generator for all chess squares\"\"\"\n    for square in chess.SQUARES:\n        tsquare = self.tsquares[square]\n        yield tsquare\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.idealColoredBoard","title":"<code>idealColoredBoard(w, h, transformation=Transformation.IDEAL)</code>","text":"<p>draw an 'ideal' colored board according to a given set of parameters e.g. fieldColor, pieceColor, pieceRadius</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def idealColoredBoard(self, w, h, transformation=Transformation.IDEAL):\n    \"\"\"draw an 'ideal' colored board according to a given set of parameters e.g. fieldColor, pieceColor, pieceRadius\"\"\"\n    idealImage = self.video.getEmptyImage4WidthAndHeight(w, h, 3)\n    for tsquare in self.genSquares():\n        tsquare.drawState(idealImage, transformation, 3)\n    return ChessBoardImage(idealImage, \"ideal\")\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.preMoveBoard","title":"<code>preMoveBoard(w, h)</code>","text":"<p>get an image of the board as it was before any move</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def preMoveBoard(self, w, h):\n    \"\"\"get an image of the board as it was before any move\"\"\"\n    refImage = self.video.getEmptyImage4WidthAndHeight(w, h, 3)\n    for tsquare in self.genSquares():\n        tsquare.addPreMoveImage(refImage)\n    return ChessBoardImage(refImage, \"preMove ref\")\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.prepareImageSet","title":"<code>prepareImageSet(cbImageSet)</code>","text":"<p>prepare the image set</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def prepareImageSet(self, cbImageSet):\n    \"\"\"prepare the image set\"\"\"\n    cbWarped = self.warpedBoardImage(cbImageSet.cbImage.image)\n    averageColors = self.analyzeColors(cbWarped)\n    cbImageSet.cbWarped = cbWarped\n    cbIdeal = self.idealColoredBoard(cbWarped.width, cbWarped.height)\n    cbImageSet.cbIdeal = cbIdeal\n    cbImageSet.cbPreMove = self.preMoveBoard(cbWarped.width, cbWarped.height)\n    cbImageSet.cbDiff = cbWarped.diffBoardImage(cbIdeal)\n    return averageColors\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.rotateIndices","title":"<code>rotateIndices(row, col, rotation)</code>","text":"<p>rotate the indices or rows and columns according to the board rotation</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def rotateIndices(self, row, col, rotation):\n    \"\"\"rotate the indices or rows and columns according to the board rotation\"\"\"\n    if rotation == 0:\n        return row, col\n    elif rotation == 90:\n        return ChessTrapezoid.cols - 1 - col, row\n    elif rotation == 180:\n        return ChessTrapezoid.rows - 1 - row, ChessTrapezoid.cols - 1 - col\n    elif rotation == 270:\n        return col, ChessTrapezoid.rows - 1 - row\n    else:\n        raise Exception(\"invalid rotation %d for rotateIndices\" % rotation)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.tSquareAt","title":"<code>tSquareAt(row, col, rotation=0)</code>","text":"<p>get the trapezoid chessboard square for the given row and column</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def tSquareAt(self, row, col, rotation=0):\n    \"\"\"get the trapezoid chessboard square for the given row and column\"\"\"\n    row, col = self.rotateIndices(row, col, rotation)\n    squareIndex = (ChessTrapezoid.rows - 1 - row) * ChessTrapezoid.cols + col\n    square = chess.SQUARES[squareIndex]\n    return self.tsquares[square]\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.ChessTrapezoid.updatePieces","title":"<code>updatePieces(fen)</code>","text":"<p>update the piece positions according to the given FEN</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def updatePieces(self, fen):\n    \"\"\"update the piece positions according to the given FEN\"\"\"\n    self.board = chess.Board(fen)\n    for tsquare in self.genSquares():\n        piece = self.board.piece_at(tsquare.square)\n        tsquare.piece = piece\n        tsquare.fieldState = tsquare.getFieldState()\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.Color","title":"<code>Color</code>","text":"<p>Color definitions with maximum lightness difference and calculation of average color for a sample of square with a given fieldState</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>class Color:\n    \"\"\"Color definitions with maximum lightness difference and calculation of average color for a sample of square with a given fieldState\"\"\"\n\n    white = (255, 255, 255)\n    lightgrey = (170, 170, 170)\n    darkgrey = (85, 85, 85)\n    black = (0, 0, 0)\n    debug = False\n\n    def __init__(self, image):\n        \"\"\"pick the average color from the given image\"\"\"\n        # https://stackoverflow.com/a/43112217/1497139\n        (means, stds) = cv2.meanStdDev(image)\n        pixels, nonzero = Color.countNonZero(image)\n        # exotic case of a totally black picture\n        if nonzero == 0:\n            self.color = (0, 0, 0)\n            self.stds = (0, 0, 0)\n        else:\n            self.color, self.stds = self.fixMeans(means, stds, pixels, nonzero)\n\n    @staticmethod\n    def countNonZero(image):\n        # https://stackoverflow.com/a/55163686/1497139\n        b = image[:, :, 0]\n        g = image[:, :, 1]\n        r = image[:, :, 2]\n        h, w = image.shape[:2]\n        pixels = h * w\n        nonzerotupel = cv2.countNonZero(b), cv2.countNonZero(g), cv2.countNonZero(r)\n        nonzero = max(nonzerotupel)\n        return pixels, nonzero\n\n    def __str__(self):\n        b, g, r = self.color\n        bs, gs, rs = self.stds\n        s = \"%3d, %3d, %3d \u00b1 %3d, %3d, %3d \" % (b, g, r, bs, gs, rs)\n        return s\n\n    def fix(self, value):\n        return 0 if value &lt; 0 else 255 if value &gt; 255 else value\n\n    def colorRange(self, rangeFactor):\n        b, g, r = self.color\n        bs, gs, rs = self.stds\n        rf = rangeFactor\n        lower = np.array(\n            [self.fix(b - bs * rf), self.fix(g - gs * rf), self.fix(r - rs * rf)],\n            dtype=\"uint8\",\n        )\n        upper = np.array(\n            [self.fix(b + bs * rf), self.fix(g + gs * rf), self.fix(r + rs * rf)],\n            dtype=\"uint8\",\n        )\n        return lower, upper\n\n    def fixMeans(self, means, stds, pixels, nonzero):\n        \"\"\"fix the zero based means to nonzero based see https://stackoverflow.com/a/58891531/1497139\"\"\"\n        gmean, bmean, rmean = means.flatten()\n        gstds, bstds, rstds = stds.flatten()\n        if Color.debug:\n            print(\"means %.2f %.2f %.2f \" % (gmean, bmean, rmean))\n            print(\"stds  %.2f %.2f %.2f \" % (gstds, bstds, rstds))\n        factor = pixels / nonzero\n        fgmean = gmean * factor\n        fbmean = bmean * factor\n        frmean = rmean * factor\n        if Color.debug:\n            print(\"non-zero means %.2f %.2f %.2f\" % (fgmean, fbmean, frmean))\n        fsqsumb = (bstds * bstds + bmean * bmean) * pixels\n        fsqsumg = (gstds * gstds + gmean * gmean) * pixels\n        fsqsumr = (rstds * rstds + rmean * rmean) * pixels\n        if Color.debug:\n            print(\"fsqsum %.2f %.2f %.2f\" % (fsqsumb, fsqsumg, fsqsumr))\n        fstdsb = math.sqrt(max(fsqsumb / nonzero - fbmean * fbmean, 0))\n        fstdsg = math.sqrt(max(fsqsumg / nonzero - fgmean * fgmean, 0))\n        fstdsr = math.sqrt(max(fsqsumr / nonzero - frmean * frmean, 0))\n        if Color.debug:\n            print(\"non-zero stds %.2f %.2f %.2f\" % (fstdsb, fstdsg, fstdsr))\n        fixedmeans = fgmean, fbmean, frmean\n        fixedstds = fstdsb, fstdsg, fstdsr\n        return fixedmeans, fixedstds\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.Color.__init__","title":"<code>__init__(image)</code>","text":"<p>pick the average color from the given image</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def __init__(self, image):\n    \"\"\"pick the average color from the given image\"\"\"\n    # https://stackoverflow.com/a/43112217/1497139\n    (means, stds) = cv2.meanStdDev(image)\n    pixels, nonzero = Color.countNonZero(image)\n    # exotic case of a totally black picture\n    if nonzero == 0:\n        self.color = (0, 0, 0)\n        self.stds = (0, 0, 0)\n    else:\n        self.color, self.stds = self.fixMeans(means, stds, pixels, nonzero)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.Color.fixMeans","title":"<code>fixMeans(means, stds, pixels, nonzero)</code>","text":"<p>fix the zero based means to nonzero based see https://stackoverflow.com/a/58891531/1497139</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def fixMeans(self, means, stds, pixels, nonzero):\n    \"\"\"fix the zero based means to nonzero based see https://stackoverflow.com/a/58891531/1497139\"\"\"\n    gmean, bmean, rmean = means.flatten()\n    gstds, bstds, rstds = stds.flatten()\n    if Color.debug:\n        print(\"means %.2f %.2f %.2f \" % (gmean, bmean, rmean))\n        print(\"stds  %.2f %.2f %.2f \" % (gstds, bstds, rstds))\n    factor = pixels / nonzero\n    fgmean = gmean * factor\n    fbmean = bmean * factor\n    frmean = rmean * factor\n    if Color.debug:\n        print(\"non-zero means %.2f %.2f %.2f\" % (fgmean, fbmean, frmean))\n    fsqsumb = (bstds * bstds + bmean * bmean) * pixels\n    fsqsumg = (gstds * gstds + gmean * gmean) * pixels\n    fsqsumr = (rstds * rstds + rmean * rmean) * pixels\n    if Color.debug:\n        print(\"fsqsum %.2f %.2f %.2f\" % (fsqsumb, fsqsumg, fsqsumr))\n    fstdsb = math.sqrt(max(fsqsumb / nonzero - fbmean * fbmean, 0))\n    fstdsg = math.sqrt(max(fsqsumg / nonzero - fgmean * fgmean, 0))\n    fstdsr = math.sqrt(max(fsqsumr / nonzero - frmean * frmean, 0))\n    if Color.debug:\n        print(\"non-zero stds %.2f %.2f %.2f\" % (fstdsb, fstdsg, fstdsr))\n    fixedmeans = fgmean, fbmean, frmean\n    fixedstds = fstdsb, fstdsg, fstdsr\n    return fixedmeans, fixedstds\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.FieldColorStats","title":"<code>FieldColorStats</code>","text":"<p>               Bases: <code>object</code></p> <p>Color statistics for Fields</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>class FieldColorStats(object):\n    \"\"\"Color statistics for Fields\"\"\"\n\n    def __init__(self):\n        self.stats = {}\n        self.colorPercent = {}\n        for fieldState in FieldState:\n            self.stats[fieldState] = MinMaxStats()\n\n    def push(self, fieldState, an, percent):\n        self.colorPercent[an] = percent\n        self.stats[fieldState].push(percent)\n\n    def analyzeStats(self, factor, time, debug=False):\n        self.factor = factor\n        self.whiteEmptyMin = self.stats[FieldState.WHITE_EMPTY].min\n        self.whiteFilledMax = max(\n            self.stats[FieldState.WHITE_BLACK].max,\n            self.stats[FieldState.WHITE_WHITE].max,\n        )\n        self.whiteSelectivity = self.whiteEmptyMin - self.whiteFilledMax\n        self.blackEmptyMin = self.stats[FieldState.BLACK_EMPTY].min\n        self.blackFilledMax = max(\n            self.stats[FieldState.BLACK_BLACK].max,\n            self.stats[FieldState.BLACK_WHITE].max,\n        )\n        self.blackSelectivity = self.blackEmptyMin - self.blackFilledMax\n        self.minSelectivity = min(self.whiteSelectivity, self.blackSelectivity)\n        if debug:\n            self.showDebug(time)\n\n    def showDebug(self, time):\n        print(\"color check %.3f s with factor %.2f\" % ((time), self.factor))\n        for fieldState in FieldState:\n            self.showFieldStateDebug(fieldState)\n\n    def showFieldStateDebug(self, fieldState):\n        print(\n            \"%20s: %s\"\n            % (\n                fieldState.title(),\n                self.stats[fieldState].formatMinMax(\n                    formatR=\"%2d: %4.1f \u00b1 %4.1f\", formatM=\" %4.1f - %4.1f\"\n                ),\n            )\n        )\n\n    def showStatsDebug(self, time):\n        print(\n            \"%.3fs for color check optimization factor: %5.1f selectivity min %5.1f,white: %5.1f black: %5.1f\"\n            % (\n                time,\n                self.factor,\n                self.minSelectivity,\n                self.whiteSelectivity,\n                self.blackSelectivity,\n            )\n        )\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.SquareChange","title":"<code>SquareChange</code>","text":"<p>keep track of changes of a square over time</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>class SquareChange:\n    \"\"\"keep track of changes of a square over time\"\"\"\n\n    meanFrameCount = 10\n    treshold = 0.2\n\n    def __init__(self, value, stats):\n        \"\"\"construct me from the given value with the given running stats\"\"\"\n        self.value = value\n        self.mean = stats.mean()\n        self.diff = value - self.mean\n        self.variance = stats.variance()\n        if stats.n &lt; SquareChange.meanFrameCount:\n            stats.push(value)\n            self.valid = False\n            self.diff = 0\n        else:\n            self.valid = abs(self.diff) &lt; SquareChange.treshold\n\n    def push(self, stats, value):\n        if self.valid:\n            stats.push(value)\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.SquareChange.__init__","title":"<code>__init__(value, stats)</code>","text":"<p>construct me from the given value with the given running stats</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def __init__(self, value, stats):\n    \"\"\"construct me from the given value with the given running stats\"\"\"\n    self.value = value\n    self.mean = stats.mean()\n    self.diff = value - self.mean\n    self.variance = stats.variance()\n    if stats.n &lt; SquareChange.meanFrameCount:\n        stats.push(value)\n        self.valid = False\n        self.diff = 0\n    else:\n        self.valid = abs(self.diff) &lt; SquareChange.treshold\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.Transformation","title":"<code>Transformation</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Transformation kind</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>class Transformation(IntEnum):\n    \"\"\"Transformation kind\"\"\"\n\n    RELATIVE = 0  # 1.0 x 1.0\n    IDEAL = 1  # e.g. 640x640\n    ORIGINAL = 2  # whatever the image size is\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.Trapez2Square","title":"<code>Trapez2Square</code>","text":"<p>transform a trapez to a square and back as needed</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>class Trapez2Square:\n    \"\"\"transform a trapez to a square and back as needed\"\"\"\n\n    def __init__(self, topLeft, topRight, bottomRight, bottomLeft):\n        \"\"\"construct me from the given corner points\"\"\"\n        self.tl, self.tr, self.br, self.bl = topLeft, topRight, bottomRight, bottomLeft\n        self.polygon = np.array(\n            [topLeft, topRight, bottomRight, bottomLeft], dtype=np.int32\n        )\n        # prepare the perspective transformation\n        # https://stackoverflow.com/questions/27585355/python-open-cv-perspectivetransform\n        # https://stackoverflow.com/a/41768610/1497139\n        # the destination\n        self.pts_dst = np.asarray(\n            [topLeft, topRight, bottomRight, bottomLeft], dtype=np.float32\n        )\n        # the normed square described as a polygon in clockwise direction with an origin at top left\n        self.pts_normedSquare = np.asarray(\n            [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]], dtype=np.float32\n        )\n        self.transform = cv2.getPerspectiveTransform(\n            self.pts_normedSquare, self.pts_dst\n        )\n\n    def relativeToTrapezXY(self, rx, ry):\n        \"\"\"convert a relative 0-1 based coordinate to a coordinate in the trapez\"\"\"\n        # see https://math.stackexchange.com/questions/2084647/obtain-two-dimensional-linear-space-on-trapezoid-shape\n        # https://stackoverflow.com/a/33303869/1497139\n        rxry = np.asarray([[rx, ry]], dtype=np.float32)\n        # target array - values are irrelevant because the will be overridden\n        xya = cv2.perspectiveTransform(np.array([rxry]), self.transform)\n        # example result:\n        # ndarray: [[[20. 40.]]]\n        xy = xya[0][0]\n        x, y = xy[0], xy[1]\n        return x, y\n\n    def relativeTrapezToTrapezXY(self, rx1, ry1, rx2, ry2):\n        return np.asarray(\n            [\n                self.relativeToTrapezXY(rx1, ry1),\n                self.relativeToTrapezXY(rx2, ry1),\n                self.relativeToTrapezXY(rx2, ry2),\n                self.relativeToTrapezXY(rx1, ry2),\n            ],\n            dtype=np.int32,\n        )\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.Trapez2Square.__init__","title":"<code>__init__(topLeft, topRight, bottomRight, bottomLeft)</code>","text":"<p>construct me from the given corner points</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def __init__(self, topLeft, topRight, bottomRight, bottomLeft):\n    \"\"\"construct me from the given corner points\"\"\"\n    self.tl, self.tr, self.br, self.bl = topLeft, topRight, bottomRight, bottomLeft\n    self.polygon = np.array(\n        [topLeft, topRight, bottomRight, bottomLeft], dtype=np.int32\n    )\n    # prepare the perspective transformation\n    # https://stackoverflow.com/questions/27585355/python-open-cv-perspectivetransform\n    # https://stackoverflow.com/a/41768610/1497139\n    # the destination\n    self.pts_dst = np.asarray(\n        [topLeft, topRight, bottomRight, bottomLeft], dtype=np.float32\n    )\n    # the normed square described as a polygon in clockwise direction with an origin at top left\n    self.pts_normedSquare = np.asarray(\n        [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]], dtype=np.float32\n    )\n    self.transform = cv2.getPerspectiveTransform(\n        self.pts_normedSquare, self.pts_dst\n    )\n</code></pre>"},{"location":"#pcwawc.chesstrapezoid.Trapez2Square.relativeToTrapezXY","title":"<code>relativeToTrapezXY(rx, ry)</code>","text":"<p>convert a relative 0-1 based coordinate to a coordinate in the trapez</p> Source code in <code>pcwawc/chesstrapezoid.py</code> <pre><code>def relativeToTrapezXY(self, rx, ry):\n    \"\"\"convert a relative 0-1 based coordinate to a coordinate in the trapez\"\"\"\n    # see https://math.stackexchange.com/questions/2084647/obtain-two-dimensional-linear-space-on-trapezoid-shape\n    # https://stackoverflow.com/a/33303869/1497139\n    rxry = np.asarray([[rx, ry]], dtype=np.float32)\n    # target array - values are irrelevant because the will be overridden\n    xya = cv2.perspectiveTransform(np.array([rxry]), self.transform)\n    # example result:\n    # ndarray: [[[20. 40.]]]\n    xy = xya[0][0]\n    x, y = xy[0], xy[1]\n    return x, y\n</code></pre>"},{"location":"#pcwawc.chessvision","title":"<code>chessvision</code>","text":"<p>Created on 2019-10-10</p> <p>@author: wf see e.g. https://www.fide.com/FIDE/handbook/LawsOfChess.pdf</p>"},{"location":"#pcwawc.chessvision.FieldState","title":"<code>FieldState</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>the state of a field is a combination of the field color with a piece color + two empty field color options</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class FieldState(IntEnum):\n    \"\"\"the state of a field is a combination of the field color with a piece color + two empty field color options\"\"\"\n\n    WHITE_EMPTY = 0\n    WHITE_WHITE = 1\n    WHITE_BLACK = 2\n    BLACK_EMPTY = 3\n    BLACK_WHITE = 4\n    BLACK_BLACK = 5\n\n    def title(\n        self,\n        titles=[\n            \"white empty\",\n            \"white on white\",\n            \"black on white\",\n            \"black empty\",\n            \"white on black\",\n            \"black on black\",\n        ],\n    ):\n        return titles[self]\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoard","title":"<code>IChessBoard</code>","text":"<p>               Bases: <code>Interface</code></p> <p>chessboard</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class IChessBoard(Interface):\n    \"\"\"chessboard\"\"\"\n\n    fen = Attribute(\"Forsyth\u2013Edwards Notation\")\n\n    def divideInSquares(self, width, height):\n        \"\"\"divide the board in squares based on the given width and height\"\"\"\n        pass\n\n    def genSquares(self):\n        \"\"\"generate all my squares\"\"\"\n        pass\n\n    def updatePieces(self, fen):\n        \"\"\"update the piece positions according to the given FEN\"\"\"\n        pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoard.divideInSquares","title":"<code>divideInSquares(width, height)</code>","text":"<p>divide the board in squares based on the given width and height</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def divideInSquares(self, width, height):\n    \"\"\"divide the board in squares based on the given width and height\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoard.genSquares","title":"<code>genSquares()</code>","text":"<p>generate all my squares</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def genSquares(self):\n    \"\"\"generate all my squares\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoard.updatePieces","title":"<code>updatePieces(fen)</code>","text":"<p>update the piece positions according to the given FEN</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def updatePieces(self, fen):\n    \"\"\"update the piece positions according to the given FEN\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoardImage","title":"<code>IChessBoardImage</code>","text":"<p>               Bases: <code>Interface</code></p> <p>a single image of a chessboard</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class IChessBoardImage(Interface):\n    \"\"\"a single image of a chessboard\"\"\"\n\n    image = Attribute(\"the chessboard image\")\n    width = Attribute(\"width of the image\")\n    height = Attribute(\"height of the image\")\n    pixels = Attribute(\"number of pixels of image = widthxheight\")\n    title = Attribute(\"title of the image\")\n\n    def diffBoardImage(self, cbOther):\n        \"\"\"get the difference image between me an the other chessboard image\"\"\"\n        pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoardImage.diffBoardImage","title":"<code>diffBoardImage(cbOther)</code>","text":"<p>get the difference image between me an the other chessboard image</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def diffBoardImage(self, cbOther):\n    \"\"\"get the difference image between me an the other chessboard image\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoardImageSet","title":"<code>IChessBoardImageSet</code>","text":"<p>               Bases: <code>Interface</code></p> <p>a set of Images</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class IChessBoardImageSet(Interface):\n    \"\"\"a set of Images\"\"\"\n\n    frameIndex = Attribute(\"index of image in a sequence\")\n    timeStamp = Attribute(\"time\")\n    cbImage = Attribute(\"original chessboard image\")\n    cbGUI = Attribute(\"the chessboard image to be displayed in the GUI\")\n    cbWarped = Attribute(\"chessboard image warped to square size\")\n    cbIdeal = Attribute(\"ideal chessboard image constructed from parameters\")\n    cbPreMove = Attribute(\"chessboard image before move\")\n    cbDiff = Attribute(\"chessboard image difference to premove state\")\n\n    def warpAndRotate(self):\n        \"\"\"warp and rotate the original image\"\"\"\n\n    def prepareGUI(self):\n        \"\"\"prepare the gui output e.g. for debugging\"\"\"\n        pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoardImageSet.prepareGUI","title":"<code>prepareGUI()</code>","text":"<p>prepare the gui output e.g. for debugging</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def prepareGUI(self):\n    \"\"\"prepare the gui output e.g. for debugging\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoardImageSet.warpAndRotate","title":"<code>warpAndRotate()</code>","text":"<p>warp and rotate the original image</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def warpAndRotate(self):\n    \"\"\"warp and rotate the original image\"\"\"\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoardVision","title":"<code>IChessBoardVision</code>","text":"<p>               Bases: <code>Interface</code></p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class IChessBoardVision(Interface):\n    title = Attribute(\"name/title of the chessboard observation\")\n    warp = Attribute(\"the trapzeoid coordinates for warping to a square image\")\n    args = Attribute(\"the command line arguments/settings\")\n    debug = Attribute(\"true for debugging\")\n    \"\"\" visual observer of a chessboard e.g. with a camera - a video or still image\"\"\"\n\n    def open(self, device):\n        \"\"\"open the access to the chessboard images via the given device e.g. device number or filepath\"\"\"\n        pass\n\n    def readChessBoardImage(self):\n        \"\"\"read a chessboard Image and return it\"\"\"\n        pass\n\n    def close(self):\n        \"\"\"close the access to the chessboard images\"\"\"\n        pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoardVision.debug","title":"<code>debug = Attribute('true for debugging')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>visual observer of a chessboard e.g. with a camera - a video or still image</p>"},{"location":"#pcwawc.chessvision.IChessBoardVision.close","title":"<code>close()</code>","text":"<p>close the access to the chessboard images</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def close(self):\n    \"\"\"close the access to the chessboard images\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoardVision.open","title":"<code>open(device)</code>","text":"<p>open the access to the chessboard images via the given device e.g. device number or filepath</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def open(self, device):\n    \"\"\"open the access to the chessboard images via the given device e.g. device number or filepath\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IChessBoardVision.readChessBoardImage","title":"<code>readChessBoardImage()</code>","text":"<p>read a chessboard Image and return it</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def readChessBoardImage(self):\n    \"\"\"read a chessboard Image and return it\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IGame","title":"<code>IGame</code>","text":"<p>               Bases: <code>Interface</code></p> <p>a chess game</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class IGame(Interface):\n    \"\"\"a chess game\"\"\"\n\n    pgn = Attribute(\"Portable game notation\")\n</code></pre>"},{"location":"#pcwawc.chessvision.IMoveDetector","title":"<code>IMoveDetector</code>","text":"<p>               Bases: <code>Interface</code></p> <p>a detector for moves on a chessboard image</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class IMoveDetector(Interface):\n    \"\"\"a detector for moves on a chessboard image\"\"\"\n\n    name = Attribute(\"name of the detector\")\n    debug = Attribute(\"true for debugging\")\n\n    def setup(self, name, board, video, args):\n        \"\"\"setup the detector with the given board, video and arguments\"\"\"\n\n    def onChessBoardImage(self, imageEvent):\n        \"\"\"event handler for image events\"\"\"\n        pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IMoveDetector.onChessBoardImage","title":"<code>onChessBoardImage(imageEvent)</code>","text":"<p>event handler for image events</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def onChessBoardImage(self, imageEvent):\n    \"\"\"event handler for image events\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IMoveDetector.setup","title":"<code>setup(name, board, video, args)</code>","text":"<p>setup the detector with the given board, video and arguments</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def setup(self, name, board, video, args):\n    \"\"\"setup the detector with the given board, video and arguments\"\"\"\n</code></pre>"},{"location":"#pcwawc.chessvision.IPiece","title":"<code>IPiece</code>","text":"<p>               Bases: <code>Interface</code></p> <p>a chess piece King,Queen,Bishop,Knight,Rook or Pawn</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class IPiece(Interface):\n    \"\"\"a chess piece King,Queen,Bishop,Knight,Rook or Pawn\"\"\"\n\n    color = Attribute(\"color of the piece\")\n</code></pre>"},{"location":"#pcwawc.chessvision.ISquare","title":"<code>ISquare</code>","text":"<p>               Bases: <code>Interface</code></p> <p>one of the 64 square fields of a chessboard</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class ISquare(Interface):\n    \"\"\"one of the 64 square fields of a chessboard\"\"\"\n\n    board = Attribute(\"the chessboard this square belongs to\")\n    an = Attribute(\"algebraic notation\")\n    fieldColor = Attribute(\"color of the empty square\")\n    piece = Attribute(\"chess piece currently on the square - may be None\")\n\n    def getSquareImage(self, cbImage):\n        \"\"\"get the 1/64 subimage of this square for the given chessboard image\"\"\"\n        pass\n</code></pre>"},{"location":"#pcwawc.chessvision.ISquare.getSquareImage","title":"<code>getSquareImage(cbImage)</code>","text":"<p>get the 1/64 subimage of this square for the given chessboard image</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def getSquareImage(self, cbImage):\n    \"\"\"get the 1/64 subimage of this square for the given chessboard image\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IWarp","title":"<code>IWarp</code>","text":"<p>               Bases: <code>Interface</code></p> <p>trapez to square warp point handling</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>class IWarp(Interface):\n    \"\"\"trapez to square warp point handling\"\"\"\n\n    def rotate(self, angle):\n        \"\"\"rotate me with the given angle\"\"\"\n        pass\n\n    def updatePoints(self):\n        \"\"\"update the points\"\"\"\n\n    def addPoint(self, px, py):\n        \"\"\"add the given point to the warp point list\"\"\"\n        pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IWarp.addPoint","title":"<code>addPoint(px, py)</code>","text":"<p>add the given point to the warp point list</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def addPoint(self, px, py):\n    \"\"\"add the given point to the warp point list\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IWarp.rotate","title":"<code>rotate(angle)</code>","text":"<p>rotate me with the given angle</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def rotate(self, angle):\n    \"\"\"rotate me with the given angle\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.chessvision.IWarp.updatePoints","title":"<code>updatePoints()</code>","text":"<p>update the points</p> Source code in <code>pcwawc/chessvision.py</code> <pre><code>def updatePoints(self):\n    \"\"\"update the points\"\"\"\n</code></pre>"},{"location":"#pcwawc.config","title":"<code>config</code>","text":"<p>Created on 2019-12-31</p> <p>@author: wf</p>"},{"location":"#pcwawc.config.Config","title":"<code>Config</code>","text":"<p>configuration for Play Chess With a WebCam</p> Source code in <code>pcwawc/config.py</code> <pre><code>class Config:\n    \"\"\"configuration for Play Chess With a WebCam\"\"\"\n\n    def __init__(self, configFile, config=None):\n        self.configFile = configFile\n        if config is not None:\n            self.config = config\n        else:\n            if not os.path.isfile(configFile):\n                print(\n                    \"%s is missing please create it if you'd like to e.g. use the lichess bot api\"\n                    % (configFile)\n                )\n                self.config = {}\n            else:\n                self.config = yaml.load(open(self.configFile), Loader=yaml.FullLoader)\n\n    @staticmethod\n    def default(configName=\"config\", configPath=os.getenv(\"HOME\") + \"/.pcwawc/\"):\n        configFile = configPath + configName + \".yaml\"\n        return Config(configFile)\n</code></pre>"},{"location":"#pcwawc.detectorfactory","title":"<code>detectorfactory</code>","text":"<p>Created on 2019-12-14</p> <p>@author: wf</p>"},{"location":"#pcwawc.detectstate","title":"<code>detectstate</code>","text":"<p>Created on 27.11.2019</p> <p>we could have used: see https://github.com/pytransitions/transitions see https://www.zeolearn.com/magazine/writing-maintainable-code-using-sate-machines-in-python but we don't for the time being</p> <p>@author: wf</p>"},{"location":"#pcwawc.detectstate.ChangeState","title":"<code>ChangeState</code>","text":"<p>               Bases: <code>IntEnum</code></p> Source code in <code>pcwawc/detectstate.py</code> <pre><code>class ChangeState(IntEnum):\n    \"\"\" \"\"\"\n\n    CALIBRATING = 0\n    PRE_MOVE = 1\n    IN_MOVE = 2\n    POTENTIAL_MOVE = 5\n\n    def title(self, titles=[\"calibrating\", \"pre move\", \"in move\", \"potential move\"]):\n        return titles[self]\n</code></pre>"},{"location":"#pcwawc.detectstate.DetectColorState","title":"<code>DetectColorState</code>","text":"<p>               Bases: <code>object</code></p> <p>detect state from Color Distribution</p> Source code in <code>pcwawc/detectstate.py</code> <pre><code>class DetectColorState(object):\n    \"\"\"detect state from Color Distribution\"\"\"\n\n    def __init__(self, trapez):\n        self.frames = 0\n        self.trapez = trapez\n        self.preMoveStats = None\n        self.imagePath = Environment.debugImagePath + \"states/\"\n        Environment.checkDir(self.imagePath)\n\n    def check(self, cbImage, averageColors, drawDebug=False):\n        self.frames += 1\n        startco = timer()\n        self.averageColors = averageColors\n        self.image = cbImage.image\n        self.fieldColorStats = self.trapez.optimizeColorCheck(cbImage, averageColors)\n        endco = timer()\n        if drawDebug:\n            self.fieldColorStats.showStatsDebug(endco - startco)\n            self.drawDebug()\n        valid = self.fieldColorStats.minSelectivity &gt; 0\n        if valid:\n            self.preMoveStats = self.fieldColorStats\n        if not valid and self.preMoveStats is not None:\n            for tSquare in self.trapez.genSquares():\n                state = self.squareState(\n                    self.preMoveStats,\n                    tSquare,\n                    self.fieldColorStats.colorPercent[tSquare.an],\n                )\n\n    def inRange(self, stats, fs, percent):\n        \"\"\"check if the given percent value is in the range for the given fieldStats\"\"\"\n        minValue = stats[fs].min\n        maxValue = stats[fs].max\n        return percent &gt;= minValue and percent &lt;= maxValue\n\n    def squareState(self, fieldColorStats, tSquare, percent):\n        \"\"\"determine the state of the given field tSquare with the given percent of pixels that fit the expectation\"\"\"\n        fieldState = tSquare.fieldState\n        selectivity = fieldColorStats.minSelectivity\n        state = self.inRange(fieldColorStats.stats, fieldState, percent)\n        return state\n\n    def drawDebug(self):\n        if self.preMoveStats is not None:\n            for tSquare in self.trapez.genSquares():\n                state = self.squareState(\n                    self.fieldColorStats,\n                    tSquare,\n                    self.fieldColorStats.colorPercent[tSquare.an],\n                )\n                percent = \"%.0f\" % (self.fieldColorStats.colorPercent[tSquare.an])\n                color = (0, 255, 0) if state else (0, 0, 255)\n                self.trapez.drawRCenteredText(\n                    self.image, percent, tSquare.rcx, tSquare.rcy, color\n                )\n            filepath = \"%s/colorState-%04d.jpg\" % (self.imagePath, self.frames)\n            self.trapez.video.writeImage(self.image, filepath)\n</code></pre>"},{"location":"#pcwawc.detectstate.DetectColorState.inRange","title":"<code>inRange(stats, fs, percent)</code>","text":"<p>check if the given percent value is in the range for the given fieldStats</p> Source code in <code>pcwawc/detectstate.py</code> <pre><code>def inRange(self, stats, fs, percent):\n    \"\"\"check if the given percent value is in the range for the given fieldStats\"\"\"\n    minValue = stats[fs].min\n    maxValue = stats[fs].max\n    return percent &gt;= minValue and percent &lt;= maxValue\n</code></pre>"},{"location":"#pcwawc.detectstate.DetectColorState.squareState","title":"<code>squareState(fieldColorStats, tSquare, percent)</code>","text":"<p>determine the state of the given field tSquare with the given percent of pixels that fit the expectation</p> Source code in <code>pcwawc/detectstate.py</code> <pre><code>def squareState(self, fieldColorStats, tSquare, percent):\n    \"\"\"determine the state of the given field tSquare with the given percent of pixels that fit the expectation\"\"\"\n    fieldState = tSquare.fieldState\n    selectivity = fieldColorStats.minSelectivity\n    state = self.inRange(fieldColorStats.stats, fieldState, percent)\n    return state\n</code></pre>"},{"location":"#pcwawc.detectstate.DetectState","title":"<code>DetectState</code>","text":"<p>               Bases: <code>object</code></p> <p>keeps track of the detections state</p> Source code in <code>pcwawc/detectstate.py</code> <pre><code>class DetectState(object):\n    \"\"\"\n    keeps track of the detections state\n    \"\"\"\n\n    def __init__(\n        self,\n        validDiffSumTreshold,\n        invalidDiffSumTreshold,\n        diffSumDeltaTreshold,\n        onPieceMoveDetected=None,\n        onMoveDetected=None,\n    ):\n        \"\"\"construct me\"\"\"\n        self.frames = 0\n        self.validFrames = 0\n        self.invalidFrames = 0\n        self.validDiffSumTreshold = validDiffSumTreshold\n        self.invalidDiffSumTreshold = invalidDiffSumTreshold\n        self.diffSumDeltaTreshold = diffSumDeltaTreshold\n        self.onPieceMoveDetected = onPieceMoveDetected\n        self.onMoveDetecte = onMoveDetected\n\n    def check(self, validChanges, diffSum, diffSumDelta, meanFrameCount):\n        \"\"\"check the detection state given the current diffSum and diffSumDelta\"\"\"\n        self.invalidStarted = self.invalidFrames &gt; 3\n        self.invalidStable = (self.invalidFrames &gt;= meanFrameCount,)\n        self.validStable = self.validFrames &gt;= meanFrameCount\n        # trigger statistics push if valid\n        if self.invalidStable:\n            self.validBoard = (\n                diffSum &lt; self.invalidDiffSumTreshold\n                and abs(diffSumDelta) &lt; self.diffSumDeltaTreshold\n                and validChanges &gt;= 62\n            )\n        else:\n            self.validBoard = diffSum &lt; self.validDiffSumTreshold\n        if self.validBoard:\n            self.validFrames += 1\n        else:\n            self.invalidFrames += 1\n\n    def nextFrame(self):\n        self.frames += 1\n\n    def invalidEnd(self):\n        self.invalidFrames = 0\n\n    def validEnd(self):\n        self.validFrames = 0\n</code></pre>"},{"location":"#pcwawc.detectstate.DetectState.__init__","title":"<code>__init__(validDiffSumTreshold, invalidDiffSumTreshold, diffSumDeltaTreshold, onPieceMoveDetected=None, onMoveDetected=None)</code>","text":"<p>construct me</p> Source code in <code>pcwawc/detectstate.py</code> <pre><code>def __init__(\n    self,\n    validDiffSumTreshold,\n    invalidDiffSumTreshold,\n    diffSumDeltaTreshold,\n    onPieceMoveDetected=None,\n    onMoveDetected=None,\n):\n    \"\"\"construct me\"\"\"\n    self.frames = 0\n    self.validFrames = 0\n    self.invalidFrames = 0\n    self.validDiffSumTreshold = validDiffSumTreshold\n    self.invalidDiffSumTreshold = invalidDiffSumTreshold\n    self.diffSumDeltaTreshold = diffSumDeltaTreshold\n    self.onPieceMoveDetected = onPieceMoveDetected\n    self.onMoveDetecte = onMoveDetected\n</code></pre>"},{"location":"#pcwawc.detectstate.DetectState.check","title":"<code>check(validChanges, diffSum, diffSumDelta, meanFrameCount)</code>","text":"<p>check the detection state given the current diffSum and diffSumDelta</p> Source code in <code>pcwawc/detectstate.py</code> <pre><code>def check(self, validChanges, diffSum, diffSumDelta, meanFrameCount):\n    \"\"\"check the detection state given the current diffSum and diffSumDelta\"\"\"\n    self.invalidStarted = self.invalidFrames &gt; 3\n    self.invalidStable = (self.invalidFrames &gt;= meanFrameCount,)\n    self.validStable = self.validFrames &gt;= meanFrameCount\n    # trigger statistics push if valid\n    if self.invalidStable:\n        self.validBoard = (\n            diffSum &lt; self.invalidDiffSumTreshold\n            and abs(diffSumDelta) &lt; self.diffSumDeltaTreshold\n            and validChanges &gt;= 62\n        )\n    else:\n        self.validBoard = diffSum &lt; self.validDiffSumTreshold\n    if self.validBoard:\n        self.validFrames += 1\n    else:\n        self.invalidFrames += 1\n</code></pre>"},{"location":"#pcwawc.environment","title":"<code>environment</code>","text":""},{"location":"#pcwawc.environment.Environment","title":"<code>Environment</code>","text":"<p>Runtime Environment</p> Source code in <code>pcwawc/environment.py</code> <pre><code>class Environment:\n    \"\"\"Runtime Environment\"\"\"\n\n    debugImagePath = \"/tmp/pcwawc/\"\n\n    def __init__(self):\n        \"\"\"get the directory in which the testMedia resides\"\"\"\n        self.scriptPath = Path(__file__).parent\n        self.projectPath = self.scriptPath.parent\n        self.testMediaPath = Path(self.projectPath, \"testMedia\")\n        self.testMedia = str(self.testMediaPath.absolute()) + \"/\"\n        self.games = str(self.projectPath) + \"/games\"\n\n    @staticmethod\n    def checkDir(path):\n        # print (path)\n        if not os.path.isdir(path):\n            try:\n                os.mkdir(path)\n            except OSError:\n                print(\"Creation of the directory %s failed\" % path)\n            else:\n                print(\"Successfully created the directory %s \" % path)\n\n    @staticmethod\n    def inContinuousIntegration():\n        \"\"\"\n        are we in a Continuous Integration Environment?\n        \"\"\"\n        publicCI = getpass.getuser() in [\"travis\", \"runner\"]\n        privateCI = \"capri.bitplan.com\" == socket.getfqdn()\n        return publicCI or privateCI\n</code></pre>"},{"location":"#pcwawc.environment.Environment.__init__","title":"<code>__init__()</code>","text":"<p>get the directory in which the testMedia resides</p> Source code in <code>pcwawc/environment.py</code> <pre><code>def __init__(self):\n    \"\"\"get the directory in which the testMedia resides\"\"\"\n    self.scriptPath = Path(__file__).parent\n    self.projectPath = self.scriptPath.parent\n    self.testMediaPath = Path(self.projectPath, \"testMedia\")\n    self.testMedia = str(self.testMediaPath.absolute()) + \"/\"\n    self.games = str(self.projectPath) + \"/games\"\n</code></pre>"},{"location":"#pcwawc.environment.Environment.inContinuousIntegration","title":"<code>inContinuousIntegration()</code>  <code>staticmethod</code>","text":"<p>are we in a Continuous Integration Environment?</p> Source code in <code>pcwawc/environment.py</code> <pre><code>@staticmethod\ndef inContinuousIntegration():\n    \"\"\"\n    are we in a Continuous Integration Environment?\n    \"\"\"\n    publicCI = getpass.getuser() in [\"travis\", \"runner\"]\n    privateCI = \"capri.bitplan.com\" == socket.getfqdn()\n    return publicCI or privateCI\n</code></pre>"},{"location":"#pcwawc.environment4test","title":"<code>environment4test</code>","text":""},{"location":"#pcwawc.environment4test.Environment4Test","title":"<code>Environment4Test</code>","text":"<p>               Bases: <code>Environment</code></p> <p>Test Environment</p> Source code in <code>pcwawc/environment4test.py</code> <pre><code>class Environment4Test(Environment):\n    \"\"\"Test Environment\"\"\"\n\n    warpPointList = [\n        ([427, 180], [962, 180], [952, 688], [430, 691]),\n        ([288, 76], [1057, 93], [1050, 870], [262, 866]),\n        ([132, 89], [492, 90], [497, 451], [122, 462]),\n        ([143, 18], [511, 13], [511, 387], [147, 386]),\n        ([260, 101], [962, 133], [950, 815], [250, 819]),\n        ([250, 108], [960, 135], [947, 819], [242, 828]),\n        ([277, 106], [972, 129], [957, 808], [270, 800]),\n        ([278, 88], [999, 88], [1072, 808], [124, 786]),\n        ([360, 238], [2380, 224], [2385, 2251], [407, 2256]),\n        ([483, 132], [1338, 124], [1541, 936], [255, 953]),\n        ([8, 1], [813, 1], [817, 812], [3, 809]),\n        ([0, 0], [522, 0], [523, 523], [0, 523]),\n        ([678, 33], [1582, 33], [1571, 923], [686, 896]),\n    ]\n\n    rotations = [0, 0, 0, 0, 270, 270, 270, 0, 0, 0, 0, 0, 270]\n\n    fens = [\n        Board.EMPTY_FEN,\n        Board.EMPTY_FEN,\n        Board.START_FEN,\n        Board.EMPTY_FEN,\n        Board.START_FEN,\n        Board.START_FEN,\n        Board.START_FEN,\n        Board.EMPTY_FEN,\n        Board.EMPTY_FEN,\n        Board.EMPTY_FEN,\n        Board.EMPTY_FEN,\n        Board.START_FEN,\n        Board.START_FEN,\n    ]\n\n    def __init__(self, headless=None):\n        \"\"\"\n        constructor\n        \"\"\"\n        super().__init__()\n        if headless is None:\n            self.headless = Environment.inContinuousIntegration()\n        else:\n            self.headless = headless\n        rlen = len(Environment4Test.rotations)\n        wlen = len(Environment4Test.warpPointList)\n        fenlen = len(Environment4Test.fens)\n        if rlen != wlen:\n            raise Exception(\"%d rotations for %d warpPoints\" % (rlen, wlen))\n        if fenlen != wlen:\n            raise Exception(\"%d FENs for %d images\" % (fenlen, wlen))\n        self.imageInfos = []\n        for num in range(1, 1000):\n            path = self.testMedia + \"chessBoard%03d.jpg\" % (num)\n            if not os.path.isfile(path):\n                break\n            if num - 1 &gt;= len(Environment4Test.rotations):\n                raise Exception(\n                    \"%d test files for %d warpPoints/rotations\" % (num, wlen)\n                )\n            imageInfo = ImageInfo(\n                num,\n                title=\"image%03d\" % (num),\n                path=path,\n                fen=Environment4Test.fens[num - 1],\n                rotation=Environment4Test.rotations[num - 1],\n                warpPoints=Environment4Test.warpPointList[num - 1],\n            )\n            self.imageInfos.append(imageInfo)\n\n    def getImage(self, num: int):\n        \"\"\"\n        get the image with the given number\n\n        Args:\n            num(int): the index of the image\n        \"\"\"\n        image, video = self.getImageWithVideo(num)\n        if video is None:\n            pass\n        return image\n\n    def getVideo(self) -&gt; Video:\n        \"\"\"\n        get a Video (potentially headless)\n\n        Returns:\n            Video: the video handler for openCV\n        \"\"\"\n        video = Video()\n        video.headless = self.headless\n        return video\n\n    def getImageWithVideo(self, num: int):\n        \"\"\"\n        get the image and video\n\n        Args:\n            num(int): the number of the image\n\n        Returns:\n            image: the image\n            video: the video display\n        \"\"\"\n        video = self.getVideo()\n        filename = self.testMedia + \"chessBoard%03d.jpg\" % (num)\n        image = video.readImage(filename)\n        height, width = image.shape[:2]\n        print(\"read image %s: %dx%d\" % (filename, width, height))\n        return image, video\n\n    def prepareFromImageInfo(self, imageInfo):\n        \"\"\"\n        prepare a test environment from the given image Inforrmation\n        \"\"\"\n        warp = Warp(list(imageInfo.warpPoints))\n        warp.rotation = imageInfo.rotation\n        image, video = self.getImageWithVideo(imageInfo.index)\n        return image, video, warp\n\n    def loadFromImageInfo(self, imageInfo):\n        analyzer = self.analyzerFromImageInfo(imageInfo)\n        start = timer()\n        cbImageSet = analyzer.vision.readChessBoardImage()\n        assert analyzer.hasImage()\n        analyzer.processImageSet(cbImageSet)\n        end = timer()\n        cbWarped = cbImageSet.cbWarped\n        print(\n            \"%.3fs for loading image %s: %4d x %4d\"\n            % ((end - start), imageInfo.title, cbWarped.width, cbWarped.height)\n        )\n        return cbImageSet.cbWarped\n\n    def analyzerFromImageInfo(self, imageInfo):\n        args = Args(\"test\")\n        args.parse(\n            [\n                \"--input\",\n                imageInfo.path,\n                \"--fen\",\n                imageInfo.fen,\n                \"--warp\",\n                imageInfo.warpPointsAsString(),\n            ]\n        )\n        analyzer = VideoAnalyzer(args.args)\n        analyzer.setUpDetector()\n        analyzer.setDebug(True)\n        analyzer.open()\n        return analyzer\n\n    def getTestVideos(self, exclude=[\"baxter.avi\"]):\n        for file in os.listdir(self.testMedia):\n            if file.endswith(\".avi\"):\n                if file not in exclude:\n                    yield file\n</code></pre>"},{"location":"#pcwawc.environment4test.Environment4Test.__init__","title":"<code>__init__(headless=None)</code>","text":"<p>constructor</p> Source code in <code>pcwawc/environment4test.py</code> <pre><code>def __init__(self, headless=None):\n    \"\"\"\n    constructor\n    \"\"\"\n    super().__init__()\n    if headless is None:\n        self.headless = Environment.inContinuousIntegration()\n    else:\n        self.headless = headless\n    rlen = len(Environment4Test.rotations)\n    wlen = len(Environment4Test.warpPointList)\n    fenlen = len(Environment4Test.fens)\n    if rlen != wlen:\n        raise Exception(\"%d rotations for %d warpPoints\" % (rlen, wlen))\n    if fenlen != wlen:\n        raise Exception(\"%d FENs for %d images\" % (fenlen, wlen))\n    self.imageInfos = []\n    for num in range(1, 1000):\n        path = self.testMedia + \"chessBoard%03d.jpg\" % (num)\n        if not os.path.isfile(path):\n            break\n        if num - 1 &gt;= len(Environment4Test.rotations):\n            raise Exception(\n                \"%d test files for %d warpPoints/rotations\" % (num, wlen)\n            )\n        imageInfo = ImageInfo(\n            num,\n            title=\"image%03d\" % (num),\n            path=path,\n            fen=Environment4Test.fens[num - 1],\n            rotation=Environment4Test.rotations[num - 1],\n            warpPoints=Environment4Test.warpPointList[num - 1],\n        )\n        self.imageInfos.append(imageInfo)\n</code></pre>"},{"location":"#pcwawc.environment4test.Environment4Test.getImage","title":"<code>getImage(num)</code>","text":"<p>get the image with the given number</p> <p>Parameters:</p> Name Type Description Default <code>num(int)</code> <p>the index of the image</p> required Source code in <code>pcwawc/environment4test.py</code> <pre><code>def getImage(self, num: int):\n    \"\"\"\n    get the image with the given number\n\n    Args:\n        num(int): the index of the image\n    \"\"\"\n    image, video = self.getImageWithVideo(num)\n    if video is None:\n        pass\n    return image\n</code></pre>"},{"location":"#pcwawc.environment4test.Environment4Test.getImageWithVideo","title":"<code>getImageWithVideo(num)</code>","text":"<p>get the image and video</p> <p>Parameters:</p> Name Type Description Default <code>num(int)</code> <p>the number of the image</p> required <p>Returns:</p> Name Type Description <code>image</code> <p>the image</p> <code>video</code> <p>the video display</p> Source code in <code>pcwawc/environment4test.py</code> <pre><code>def getImageWithVideo(self, num: int):\n    \"\"\"\n    get the image and video\n\n    Args:\n        num(int): the number of the image\n\n    Returns:\n        image: the image\n        video: the video display\n    \"\"\"\n    video = self.getVideo()\n    filename = self.testMedia + \"chessBoard%03d.jpg\" % (num)\n    image = video.readImage(filename)\n    height, width = image.shape[:2]\n    print(\"read image %s: %dx%d\" % (filename, width, height))\n    return image, video\n</code></pre>"},{"location":"#pcwawc.environment4test.Environment4Test.getVideo","title":"<code>getVideo()</code>","text":"<p>get a Video (potentially headless)</p> <p>Returns:</p> Name Type Description <code>Video</code> <code>Video</code> <p>the video handler for openCV</p> Source code in <code>pcwawc/environment4test.py</code> <pre><code>def getVideo(self) -&gt; Video:\n    \"\"\"\n    get a Video (potentially headless)\n\n    Returns:\n        Video: the video handler for openCV\n    \"\"\"\n    video = Video()\n    video.headless = self.headless\n    return video\n</code></pre>"},{"location":"#pcwawc.environment4test.Environment4Test.prepareFromImageInfo","title":"<code>prepareFromImageInfo(imageInfo)</code>","text":"<p>prepare a test environment from the given image Inforrmation</p> Source code in <code>pcwawc/environment4test.py</code> <pre><code>def prepareFromImageInfo(self, imageInfo):\n    \"\"\"\n    prepare a test environment from the given image Inforrmation\n    \"\"\"\n    warp = Warp(list(imageInfo.warpPoints))\n    warp.rotation = imageInfo.rotation\n    image, video = self.getImageWithVideo(imageInfo.index)\n    return image, video, warp\n</code></pre>"},{"location":"#pcwawc.environment4test.ImageInfo","title":"<code>ImageInfo</code>","text":"<p>information about a chessboard test image</p> Source code in <code>pcwawc/environment4test.py</code> <pre><code>class ImageInfo:\n    \"\"\"information about a chessboard test image\"\"\"\n\n    def __init__(self, index, title, path, fen, rotation, warpPoints):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.index = index\n        self.title = title\n        self.path = path\n        self.fen = fen\n        self.rotation = rotation\n        self.warpPoints = warpPoints\n\n    def warpPointsAsString(self):\n        return str(self.warpPoints)\n</code></pre>"},{"location":"#pcwawc.environment4test.ImageInfo.__init__","title":"<code>__init__(index, title, path, fen, rotation, warpPoints)</code>","text":"<p>constructor</p> Source code in <code>pcwawc/environment4test.py</code> <pre><code>def __init__(self, index, title, path, fen, rotation, warpPoints):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.index = index\n    self.title = title\n    self.path = path\n    self.fen = fen\n    self.rotation = rotation\n    self.warpPoints = warpPoints\n</code></pre>"},{"location":"#pcwawc.eventhandling","title":"<code>eventhandling</code>","text":"<p>Created on 2019-12-13</p> <p>@author: wf</p> <p>Event handling module see https://stackoverflow.com/a/1925836/1497139</p>"},{"location":"#pcwawc.eventhandling.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>object</code></p> <p>an Event</p> Source code in <code>pcwawc/eventhandling.py</code> <pre><code>class Event(object):\n    \"\"\"an Event\"\"\"\n\n    pass\n</code></pre>"},{"location":"#pcwawc.eventhandling.Observable","title":"<code>Observable</code>","text":"<p>               Bases: <code>object</code></p> <p>an Observable</p> Source code in <code>pcwawc/eventhandling.py</code> <pre><code>class Observable(object):\n    \"\"\"an Observable\"\"\"\n\n    def __init__(self):\n        self.callbacks = []\n\n    def subscribe(self, callback):\n        self.callbacks.append(callback)\n\n    def unsubscribe(self, callback):\n        if callback in self.callbacks:\n            self.callbacks.remove(callback)\n\n    def fire(self, **attrs):\n        e = Event()\n        e.source = self\n        for k, v in attrs.items():\n            setattr(e, k, v)\n        for fn in self.callbacks:\n            fn(e)\n</code></pre>"},{"location":"#pcwawc.field","title":"<code>field</code>","text":""},{"location":"#pcwawc.field.Field","title":"<code>Field</code>","text":"<p>a single Field of a chess board as observed from a WebCam</p> Source code in <code>pcwawc/field.py</code> <pre><code>@implementer(ISquare)\nclass Field:\n    \"\"\"a single Field of a chess board as observed from a WebCam\"\"\"\n\n    rows = 8\n    cols = 8\n    # bgr colors\n    white = (255, 255, 255)\n    lightGrey = (64, 64, 64)\n    grey = (128, 128, 128)\n    darkGrey = (192, 192, 192)\n    green = (0, 255, 0)\n    red = (0, 0, 255)\n    black = (0, 0, 0)\n\n    @staticmethod\n    def hsv_to_rgb(h, s, v):\n        return colorsys.hsv_to_rgb(h, s, v)\n\n    @staticmethod\n    def hsv255_to_rgb255(h, s, v):\n        r, g, b = Field.hsv_to_rgb(h / 255, s / 255, v / 255)\n        return (int(r * 255), int(g * 255), int(b * 255))\n\n    # construct me\n    def __init__(self, board, row, col):\n        self.board = board\n        # row and column indices from 0-7\n        self.row = row\n        self.col = col\n        self.squareIndex = (7 - row) * 8 + col\n        self.square = chess.SQUARES[self.squareIndex]\n        # https://python-chess.readthedocs.io/en/latest/core.html - chess.WHITE=True, chess.BLACK=False\n        # https://gamedev.stackexchange.com/a/44998/133453\n        # A8 at 0,0 is white moving an odd number of steps horizontally and vertically will end up on a black\n        self.fieldColor = (self.col + self.row) % 2 == 0\n        # algebraic notation of field\n        # A1 to H8\n        self.an = chess.SQUARE_NAMES[self.squareIndex]\n        # center pixel position of field\n        self.px = None\n        self.py = None\n        self.pcx = None\n        self.pcy = None\n        self.width = None\n        self.height = None\n        self.maxX = None\n        self.maxY = None\n        self.distance = None\n        self.step = None\n        self.hsvStats = None\n        self.rgbStats = None\n        self.luminance = None\n        self.rgbColorKey = None\n        self.colorKey = None\n\n    def getRect(self):\n        x1 = int(self.pcx - self.width / 2)\n        y1 = int(self.pcy - self.height / 2)\n        return x1, y1, int(self.width), int(self.height)\n\n    def divideInROIs(self, grid, roiLambda):\n        self.rois = []\n        for roiIndex in range(grid.rois):\n            self.rois.append(FieldROI(self, grid, roiIndex, roiLambda))\n\n    def getPiece(self):\n        if self.board is None:\n            raise Exception(\"Board not set for %s\" % (self.an))\n        if self.board.chessboard is None:\n            raise Exception(\"board.chessboard not set for %s\" % (self.an))\n        piece = self.board.chessboard.piece_at(self.square)\n        return piece\n\n    def getFieldState(self):\n        piece = self.getPiece()\n        if piece is None:\n            if self.fieldColor == chess.WHITE:\n                return FieldState.WHITE_EMPTY\n            else:\n                return FieldState.BLACK_EMPTY\n        elif piece.color == chess.WHITE:\n            if self.fieldColor == chess.WHITE:\n                return FieldState.WHITE_WHITE\n            else:\n                return FieldState.BLACK_WHITE\n        else:\n            if self.fieldColor == chess.WHITE:\n                return FieldState.WHITE_BLACK\n            else:\n                return FieldState.BLACK_BLACK\n        # this can't happen\n        return None\n\n    # analyze the color around my center pixel to the given\n    # distance\n    def analyzeColor(self, image, hsv, distance=1, step=1):\n        self.distance = distance\n        self.step = step\n        self.hsvStats = ColorStats()\n        self.rgbStats = ColorStats()\n        for dx in range(-distance * step, distance * step + 1, step):\n            for dy in range(-distance * step, distance * step + 1, step):\n                ph, ps, pv = hsv[self.pcy + dy, self.pcx + dx]\n                b, g, r = image[self.pcy + dy, self.pcx + dx]\n                # print (\"(%3d,%3d)=(%3d,%3d,%3d)\" % (self.pcx+dx,self.pcy+dy,ph,ps,pv))\n                self.hsvStats.push(ph, ps, pv)\n                self.rgbStats.push(r, g, b)\n        self.luminance = self.hsvStats.c3Stats\n        self.rgbColorKey = self.rgbStats.rgbColorKey()\n        self.colorKey = self.hsvStats.colorKey()\n\n    def getColor(self):\n        h, s, v = self.hsvStats.mean()\n        r, g, b = Field.hsv255_to_rgb255(h, s, v)\n        bgr = (b, g, r)\n        # print(\"(%3d,%3d)=(%3d,%3d,%3d) (%3d,%3d,%3d)\" % (self.pcx,self.pcy,h,s,v,r,g,b))\n        return bgr\n\n    def interPolate(self, rx, ry):\n        \"\"\"interpolate the given relative coordinate\"\"\"\n        # interpolate the pixel\n        x = int(self.pcx + self.width * (rx - 0.5) + 0.5)\n        y = int(self.pcy + self.height * (ry - 0.5) + 0.5)\n        return self.limit(x, y)\n\n    def limit(self, x, y):\n        if self.maxX is not None:\n            if x &gt;= self.maxX:\n                x = self.maxX - 1\n        if self.maxY is not None:\n            if y &gt;= self.maxY:\n                y = self.maxY - 1\n        if x &lt; 0:\n            x = 0\n        if y &lt; 0:\n            y = 0\n        pixel = (x, y)\n        return pixel\n\n    def setRect(self, width, height, fieldWidth, fieldHeight):\n        pcx = int(fieldWidth * (2 * self.col + 1) // 2)\n        pcy = int(fieldHeight * (2 * self.row + 1) // 2)\n        self.width = fieldWidth\n        self.height = fieldHeight\n        self.pcx = pcx\n        self.pcy = pcy\n        self.maxX = width\n        self.maxY = height\n\n    def getSquareImage(self, cbImage):\n        x, y, dh, dw = self.getRect()\n        squareImage = cbImage.image[y : y + dh, x : x + dw]\n        return squareImage\n\n    def drawDebug(self, video, image, detectedFieldState):\n        pcx = self.pcx\n        pcy = self.pcy\n        distance = self.distance\n        step = self.step\n        fieldState = self.getFieldState()\n        detectColor = (\n            Field.black\n        )  # Field.green if fieldState == detectedFieldState else Field.red\n        fieldColor = self.getColor()\n        x1, y1, x2, y2 = (\n            pcx - distance * step,\n            pcy - distance * step,\n            pcx + distance * step,\n            pcy + distance * step,\n        )\n        # outer thickness for displaying detect state: green ok red - there is an issue\n        ot = 2\n        # inner thickness for displaying the field color\n        it = 3\n        video.drawRectangle(\n            image,\n            (x1 - ot, y1 - ot),\n            (x2 + ot, y2 + ot),\n            thickness=ot,\n            color=detectColor,\n        )\n        video.drawRectangle(image, (x1, y1), (x2, y2), thickness=it, color=fieldColor)\n        piece = self.getPiece()\n        if piece is None:\n            emptyFieldColor = (\n                Field.white if fieldState == FieldState.WHITE_EMPTY else Field.black\n            )\n            video.drawRectangle(\n                image,\n                (x1 + it, y1 + it),\n                (x2 - it, y2 - it),\n                thickness=-1,\n                color=emptyFieldColor,\n            )\n        else:\n            symbol = piece.symbol()  # piece.unicode_symbol()\n            video.drawCenteredText(image, symbol, pcx, pcy)\n</code></pre>"},{"location":"#pcwawc.field.Field.interPolate","title":"<code>interPolate(rx, ry)</code>","text":"<p>interpolate the given relative coordinate</p> Source code in <code>pcwawc/field.py</code> <pre><code>def interPolate(self, rx, ry):\n    \"\"\"interpolate the given relative coordinate\"\"\"\n    # interpolate the pixel\n    x = int(self.pcx + self.width * (rx - 0.5) + 0.5)\n    y = int(self.pcy + self.height * (ry - 0.5) + 0.5)\n    return self.limit(x, y)\n</code></pre>"},{"location":"#pcwawc.field.FieldROI","title":"<code>FieldROI</code>","text":"<p>a region of interest within the square image area of pixels represented by some pixels</p> Source code in <code>pcwawc/field.py</code> <pre><code>class FieldROI:\n    \"\"\"a region of interest within the square image area of pixels represented by some pixels\"\"\"\n\n    # construct me from a field, a generator for relative pixels and the number of x and y steps to generate from\n    def __init__(self, field, grid, roiIndex, relPixelLambda):\n        self.relPixelLambda = relPixelLambda\n        self.grid = grid\n        self.roiIndex = roiIndex\n        self.pixels = grid.xsteps * grid.ysteps\n        self.field = field\n        self.colorStats = ColorStats()\n\n    # analyze the given region of interest for the given image\n    def analyze(self, image):\n        for pixel in self.pixelList():\n            x, y = pixel\n            c1, c2, c3 = image[y, x]\n            self.colorStats.push(c1, c2, c3)\n\n    def pixelList(self):\n        \"\"\"generate a pixel list by using the generated relative position from\"\"\"\n        for xstep in range(self.grid.xsteps):\n            for ystep in range(self.grid.ysteps):\n                rx, ry = self.relPixelLambda(self.grid, self.roiIndex, xstep, ystep)\n                rx, ry = self.grid.shiftSafety(rx, ry)\n                pixel = self.field.interPolate(rx, ry)\n                yield pixel\n</code></pre>"},{"location":"#pcwawc.field.FieldROI.pixelList","title":"<code>pixelList()</code>","text":"<p>generate a pixel list by using the generated relative position from</p> Source code in <code>pcwawc/field.py</code> <pre><code>def pixelList(self):\n    \"\"\"generate a pixel list by using the generated relative position from\"\"\"\n    for xstep in range(self.grid.xsteps):\n        for ystep in range(self.grid.ysteps):\n            rx, ry = self.relPixelLambda(self.grid, self.roiIndex, xstep, ystep)\n            rx, ry = self.grid.shiftSafety(rx, ry)\n            pixel = self.field.interPolate(rx, ry)\n            yield pixel\n</code></pre>"},{"location":"#pcwawc.field.Grid","title":"<code>Grid</code>","text":"<p>Grid Info in the region of interest</p> Source code in <code>pcwawc/field.py</code> <pre><code>class Grid:\n    \"\"\"Grid Info in the region of interest\"\"\"\n\n    def __init__(self, rois, xsteps, ysteps, safetyX=0, safetyY=0):\n        self.rois = rois\n        self.xsteps = xsteps\n        self.ysteps = ysteps\n        # safety Margin in percent\n        self.safetyX = safetyX / 100\n        self.safetyY = safetyY / 100\n\n    @staticmethod\n    def split(pStep, parts):\n        return (pStep + 1) / (parts + 1)\n\n    def xstep(self, pXStep):\n        return Grid.split(pXStep, self.xsteps)\n\n    def ystep(self, pYStep):\n        return Grid.split(pYStep, self.ysteps)\n\n    def d(self):\n        return 1 / (self.rois)\n\n    def dofs(self, roiIndex):\n        return self.d() * (roiIndex)\n\n    def safeShift(self, value, safetyMargin):\n        if safetyMargin == 0:\n            return value\n        else:\n            return value * (1 - 2 * safetyMargin) + safetyMargin\n\n    def shiftSafety(self, rx, ry):\n        return self.safeShift(rx, self.safetyX), self.safeShift(ry, self.safetyY)\n</code></pre>"},{"location":"#pcwawc.field.SquareKind","title":"<code>SquareKind</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>kind of Square</p> Source code in <code>pcwawc/field.py</code> <pre><code>class SquareKind(IntEnum):\n    \"\"\"kind of Square\"\"\"\n\n    FIELD_WHITE = 0\n    FIELD_BLACK = 1\n    PIECE_WHITE = 2\n    PIECE_BLACK = 3\n\n    def title(\n        self, titles=[\"white field\", \"black field\", \"white piece\", \"black piece\"]\n    ):\n        return titles[self]\n</code></pre>"},{"location":"#pcwawc.fpscheck","title":"<code>fpscheck</code>","text":""},{"location":"#pcwawc.fpscheck.FPSCheck","title":"<code>FPSCheck</code>","text":"<p>               Bases: <code>object</code></p> <p>Frame per second tracker</p> Source code in <code>pcwawc/fpscheck.py</code> <pre><code>class FPSCheck(object):\n    \"\"\"Frame per second tracker\"\"\"\n\n    def __init__(self):\n        # store the start time, end time, and total number of frames\n        # that were examined between the start and end intervals\n        self._start = None\n        self._end = None\n        self._numFrames = 0\n\n    def start(self):\n        # start the timer\n        self._start = datetime.datetime.now()\n        self._end = datetime.datetime.now()\n        return self\n\n    def update(self):\n        # increment the total number of frames examined during the\n        # start and end intervals\n        self._numFrames += 1\n        # update the timer\n        self._end = datetime.datetime.now()\n\n    def elapsed(self):\n        # return the total number of seconds between the start and\n        # end interval\n        return (self._end - self._start).total_seconds()\n\n    def fps(self):\n        # compute the (approximate) frames per second\n        return self._numFrames / self.elapsed()\n</code></pre>"},{"location":"#pcwawc.game","title":"<code>game</code>","text":""},{"location":"#pcwawc.game.Game","title":"<code>Game</code>","text":"<p>               Bases: <code>JsonAbleMixin</code></p> <p>keeps track of a games state</p> Source code in <code>pcwawc/game.py</code> <pre><code>@implementer(IGame)\nclass Game(JsonAbleMixin):\n    \"\"\"keeps track of a games state\"\"\"\n\n    def __init__(self, gameid):\n        self.gameid = gameid\n        self.fen = chess.STARTING_BOARD_FEN\n        # http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm\n        self.pgn = None\n        self.headers = {}\n        self.headers[\"Date\"] = strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.locked = False\n        self.moveIndex = 0\n\n    # def __getstate__(self):\n    #    state={}\n    #    state[\"gameid\"]=self.gameid\n    #    state[\"pgn\"]=self.pgn\n    #    state[\"locked\"]=self.locked\n    #    state[\"moveIndex\"]=self.moveIndex\n    #    return state\n\n    # def __setstate__(self, state):\n    #    self.gameid=state[\"gameid\"]\n    #   self.pgn=state[\"pgn\"]\n    #    self.locked=state[\"locked\"]\n    #    self.moveIndex=state[\"moveIndex\"]\n    def updateHeaders(self, headers):\n        for key, header in self.headers.items():\n            headers[key] = header\n\n    def update(self, board):\n        try:\n            game = chess.pgn.Game.from_board(board.chessboard)\n            self.updateHeaders(game.headers)\n            self.pgn = str(game)\n        except BaseException as e:\n            print(\"pgn error: %s\", str(e))\n\n    def move(self, board):\n        self.moveIndex += 1\n        self.update(board)\n\n    @staticmethod\n    def gameId():\n        gameid = strftime(\"game_%Y-%m-%d_%H%M%S\")\n        return gameid\n\n    def showDebug(self):\n        print(\"fen: %s\" % (self.fen))\n        print(\"pgn: %s\" % (self.pgn))\n        print(\"moveIndex: %d\" % (self.moveIndex))\n</code></pre>"},{"location":"#pcwawc.game.WebCamGame","title":"<code>WebCamGame</code>","text":"<p>               Bases: <code>Game</code></p> <p>keeps track of a webcam games state</p> Source code in <code>pcwawc/game.py</code> <pre><code>class WebCamGame(Game):\n    \"\"\"keeps track of a webcam games state\"\"\"\n\n    def __init__(self, gameid):\n        super(WebCamGame, self).__init__(gameid)\n        self.warp = None\n\n    def checkEnvironment(self, env):\n        Environment.checkDir(env.games)\n\n    def save(self, path=\"games\"):\n        env = Environment()\n        savepath = str(env.projectPath) + \"/\" + path\n        Environment.checkDir(savepath)\n        savedir = savepath + \"/\" + self.gameid\n        Environment.checkDir(savedir)\n        jsonFile = savedir + \"/\" + self.gameid + \"-webcamgame\"\n        self.writeJson(jsonFile)\n        gameJsonFile = savedir + \"/\" + self.gameid\n        self.writeJson(gameJsonFile)\n\n        if self.locked is not None and not self.locked:\n            if self.fen is not None:\n                fenFile = savedir + \"/\" + self.gameid + \".fen\"\n                print(self.fen, file=open(fenFile, \"w\"))\n            if self.pgn is not None:\n                pgnFile = savedir + \"/\" + self.gameid + \".pgn\"\n                # see https://python-chess.readthedocs.io/en/latest/pgn.html\n                print(self.pgn, file=open(pgnFile, \"w\"), end=\"\\n\\n\")\n        return savedir\n\n    @staticmethod\n    def createNewGame():\n        return WebCamGame(Game.gameId())\n\n    @staticmethod\n    def fromArgs(args):\n        env = Environment()\n        if args is None or args.game is None:\n            webCamGame = WebCamGame.createNewGame()\n        else:\n            gamepath = args.game\n            if not gamepath.startswith(\"/\"):\n                gamepath = env.games + \"/\" + gamepath\n            webCamGame = WebCamGame.readJson(gamepath)\n            if webCamGame is None:\n                # self.videoAnalyzer.log(\"could not read %s \" % (gamepath))\n                webCamGame = webCamGame.createNewGame()\n        webCamGame.checkEnvironment(env)\n        if args is not None:\n            if args.event is not None:\n                webCamGame.headers[\"Event\"] = args.event\n            if args.site is not None:\n                webCamGame.headers[\"Site\"] = args.site\n            if args.round is not None:\n                webCamGame.headers[\"Round\"] = args.round\n            if args.white is not None:\n                webCamGame.headers[\"White\"] = args.white\n            if args.black is not None:\n                webCamGame.headers[\"Black\"] = args.black\n\n        return webCamGame\n\n    @staticmethod\n    def getWebCamGames(path):\n        webCamGames = {}\n        for file in os.listdir(path):\n            if file.endswith(\".json\"):\n                filePath = os.path.join(path, file)\n                webCamGame = WebCamGame.readJson(filePath, \"\")\n                if isinstance(webCamGame, WebCamGame):\n                    webCamGames[webCamGame.gameid] = webCamGame\n                else:\n                    raise Exception(\"invalid json file %s\" % filePath)\n        return webCamGames\n</code></pre>"},{"location":"#pcwawc.histogram","title":"<code>histogram</code>","text":"<p>Created on 2019-11-29</p> <p>@author: wf</p>"},{"location":"#pcwawc.histogram.Histogram","title":"<code>Histogram</code>","text":"<p>Image Histogram</p> Source code in <code>pcwawc/histogram.py</code> <pre><code>class Histogram:\n    \"\"\"Image Histogram\"\"\"\n\n    colors = (\"blue\", \"green\", \"red\")\n\n    def __init__(self, image, histSize=256, histRange=(0, 256)):\n        \"\"\"construct me from the given image hist Size and histRange\"\"\"\n        self.hist = {}\n        self.stats = {}\n        self.image = image\n\n        start = timer()\n        # the upper boundary is exclusive\n        for channel in range(len(Histogram.colors)):\n            self.hist[channel] = cv2.calcHist(\n                [image], [channel], None, [histSize], histRange, accumulate=False\n            )\n            histindexed = list(enumerate(np.reshape(self.hist[channel], histSize)))\n            self.stats[channel] = Stats(histindexed)\n        bstats, gstats, rstats = self.stats[0], self.stats[1], self.stats[2]\n        self.color = (bstats.mean, gstats.mean, rstats.mean)\n        self.mincolor = (bstats.min, gstats.min, rstats.min)\n        self.maxcolor = (bstats.max, gstats.max, rstats.max)\n        self.maxdelta = (bstats.maxdelta, gstats.maxdelta, rstats.maxdelta)\n        # here we are using the color information! This should make the difference!\n        self.factor = (bstats.factor, gstats.factor, rstats.factor)\n        self.stdv = (bstats.stdv, gstats.stdv, rstats.stdv)\n        end = timer()\n        self.time = end - start\n\n    def fix(self, value):\n        return 0 if value &lt; 0 else 255 if value &gt; 255 else value\n\n    def range(self, relFactor=1.0):\n        bstats, gstats, rstats = self.stats[0], self.stats[1], self.stats[2]\n        bl, bu = bstats.range(relFactor)\n        gl, gu = gstats.range(relFactor)\n        rl, ru = rstats.range(relFactor)\n        # return np.array([bl,gl,rl],dtype = 'uint8'),np.array([bu,gu,ru],dtype='uint8')\n        return (bl, gl, rl), (bu, gu, ru)\n\n    def colorRangeWithFactor(self, rangeFactor):\n        b, g, r = self.color\n        bs, gs, rs = self.stdv\n        rf = rangeFactor\n        lower = np.array(\n            [self.fix(b - bs * rf), self.fix(g - gs * rf), self.fix(r - rs * rf)],\n            dtype=\"uint8\",\n        )\n        upper = np.array(\n            [self.fix(b + bs * rf), self.fix(g + gs * rf), self.fix(r + rs * rf)],\n            dtype=\"uint8\",\n        )\n        return lower, upper\n\n    def colorMask(self, image, rangeFactor):\n        \"\"\"create a color mask for this histogram and apply it to the given image\"\"\"\n        # lower,upper=self.colorRange(rangeFactor)\n        lower, upper = self.mincolor, self.maxcolor\n        colorMask = cv2.inRange(image, lower, upper)\n        return colorMask\n\n    def showDebug(self):\n        print(\"calculation took %.4f s\" % (self.time))\n        for channel in range(len(Histogram.colors)):\n            print(vars(self.stats[channel]))\n\n    def plotRow(self, ax1, ax2):\n        self.rgb = cv2.cvtColor(self.image, cv2.COLOR_BGR2RGB)\n        ax1.imshow(self.rgb), ax1.axis(\"off\")\n        for i, col in enumerate(Histogram.colors):\n            ax2.plot(self.hist[i], color=col)\n            # ax2.xlim([0,256])\n\n    def preparePlot(self, rows, cols, title=\"color histogram\", fontsize=20):\n        fig, axes = plt.subplots(rows, cols)\n        fig.suptitle(title, fontsize=fontsize)\n        return fig, axes\n\n    def plot(self):\n        fig, (ax1, ax2) = self.preparePlot(1, 2)\n        self.plotRow(ax1, ax2)\n        return fig\n\n    def save(self, filepath):\n        fig = self.plot()\n        self.savefig(fig, filepath)\n\n    def savefig(self, fig, filepath):\n        fig.savefig(filepath)\n        plt.close(fig)\n\n    def show(self):\n        fig = self.plot()\n        plt.show()\n        plt.close(fig)\n</code></pre>"},{"location":"#pcwawc.histogram.Histogram.__init__","title":"<code>__init__(image, histSize=256, histRange=(0, 256))</code>","text":"<p>construct me from the given image hist Size and histRange</p> Source code in <code>pcwawc/histogram.py</code> <pre><code>def __init__(self, image, histSize=256, histRange=(0, 256)):\n    \"\"\"construct me from the given image hist Size and histRange\"\"\"\n    self.hist = {}\n    self.stats = {}\n    self.image = image\n\n    start = timer()\n    # the upper boundary is exclusive\n    for channel in range(len(Histogram.colors)):\n        self.hist[channel] = cv2.calcHist(\n            [image], [channel], None, [histSize], histRange, accumulate=False\n        )\n        histindexed = list(enumerate(np.reshape(self.hist[channel], histSize)))\n        self.stats[channel] = Stats(histindexed)\n    bstats, gstats, rstats = self.stats[0], self.stats[1], self.stats[2]\n    self.color = (bstats.mean, gstats.mean, rstats.mean)\n    self.mincolor = (bstats.min, gstats.min, rstats.min)\n    self.maxcolor = (bstats.max, gstats.max, rstats.max)\n    self.maxdelta = (bstats.maxdelta, gstats.maxdelta, rstats.maxdelta)\n    # here we are using the color information! This should make the difference!\n    self.factor = (bstats.factor, gstats.factor, rstats.factor)\n    self.stdv = (bstats.stdv, gstats.stdv, rstats.stdv)\n    end = timer()\n    self.time = end - start\n</code></pre>"},{"location":"#pcwawc.histogram.Histogram.colorMask","title":"<code>colorMask(image, rangeFactor)</code>","text":"<p>create a color mask for this histogram and apply it to the given image</p> Source code in <code>pcwawc/histogram.py</code> <pre><code>def colorMask(self, image, rangeFactor):\n    \"\"\"create a color mask for this histogram and apply it to the given image\"\"\"\n    # lower,upper=self.colorRange(rangeFactor)\n    lower, upper = self.mincolor, self.maxcolor\n    colorMask = cv2.inRange(image, lower, upper)\n    return colorMask\n</code></pre>"},{"location":"#pcwawc.histogram.Stats","title":"<code>Stats</code>","text":"<p>Calculate Histogram statistics see https://math.stackexchange.com/questions/857566/how-to-get-the-standard-deviation-of-a-given-histogram-image</p> Source code in <code>pcwawc/histogram.py</code> <pre><code>class Stats:\n    \"\"\"Calculate Histogram statistics see https://math.stackexchange.com/questions/857566/how-to-get-the-standard-deviation-of-a-given-histogram-image\"\"\"\n\n    def __init__(self, histindexed):\n        self.n = len(histindexed)\n        self.max = -sys.maxsize\n        self.min = sys.maxsize\n        self.sum = 0\n        self.prod = 0\n        self.sqsum = 0\n        for x, y in histindexed:\n            self.sum += y\n            self.prod += x * y\n        self.mean = 0 if self.sum == 0 else self.prod / self.sum\n        for x, y in histindexed:\n            if y &gt; 0:\n                self.min = min(self.min, x)\n                self.max = max(self.max, x)\n            dx = x - self.mean\n            self.sqsum += y * dx * dx\n        # \u03c3\u00b2\n        self.variance = 0 if self.sqsum == 0 else self.sqsum / self.sum\n        self.stdv = math.sqrt(self.variance)\n        self.maxdelta = max(self.mean - self.min, self.max - self.mean)\n        self.factor = 0 if self.stdv == 0 else self.maxdelta / self.stdv\n        pass\n\n    def range(self, relFactor=1.0, minValue=0, maxValue=255):\n        \"\"\"return a range relative to my min max range to widen e.g. by 10% use factor 1.1\"\"\"\n        lower = self.mean - self.stdv * self.factor * relFactor\n        if lower &lt; minValue:\n            lower = minValue\n        upper = self.mean + self.stdv * self.factor * relFactor\n        if upper &gt; maxValue:\n            upper = maxValue\n        return lower, upper\n</code></pre>"},{"location":"#pcwawc.histogram.Stats.range","title":"<code>range(relFactor=1.0, minValue=0, maxValue=255)</code>","text":"<p>return a range relative to my min max range to widen e.g. by 10% use factor 1.1</p> Source code in <code>pcwawc/histogram.py</code> <pre><code>def range(self, relFactor=1.0, minValue=0, maxValue=255):\n    \"\"\"return a range relative to my min max range to widen e.g. by 10% use factor 1.1\"\"\"\n    lower = self.mean - self.stdv * self.factor * relFactor\n    if lower &lt; minValue:\n        lower = minValue\n    upper = self.mean + self.stdv * self.factor * relFactor\n    if upper &gt; maxValue:\n        upper = maxValue\n    return lower, upper\n</code></pre>"},{"location":"#pcwawc.jsonablemixin","title":"<code>jsonablemixin</code>","text":""},{"location":"#pcwawc.jsonablemixin.JsonAbleMixin","title":"<code>JsonAbleMixin</code>","text":"<p>               Bases: <code>object</code></p> <p>allow reading and writing derived objects from a json file</p> Source code in <code>pcwawc/jsonablemixin.py</code> <pre><code>class JsonAbleMixin(object):\n    \"\"\"allow reading and writing derived objects from a json file\"\"\"\n\n    debug = False\n\n    # read me from a yaml file\n    @staticmethod\n    def readJson(name, postfix=\".json\"):\n        jsonFileName = name\n        if not name.endswith(postfix):\n            jsonFileName = name + postfix\n        # is there a jsonFile for the given name\n        if os.path.isfile(jsonFileName):\n            if JsonAbleMixin.debug:\n                print(\"reading %s\" % (jsonFileName))\n            json = open(jsonFileName).read()\n            result = jsonpickle.decode(json)\n            if JsonAbleMixin.debug:\n                print(json)\n                print(result)\n            return result\n        else:\n            return None\n\n    def asJson(self):\n        json = jsonpickle.encode(self)\n        return json\n\n    # write me to the json file with the given name (without postfix)\n    def writeJson(self, name, postfix=\".json\"):\n        jsonFileName = name + postfix\n        json = self.asJson()\n        if JsonAbleMixin.debug:\n            print(\"writing %s\" % (jsonFileName))\n            print(json)\n            print(self)\n        jsonFile = open(jsonFileName, \"w\")\n        jsonFile.write(json)\n        jsonFile.close()\n</code></pre>"},{"location":"#pcwawc.lichessbridge","title":"<code>lichessbridge</code>","text":"<p>Created on 2019-12-21</p> <p>@author: wf</p>"},{"location":"#pcwawc.lichessbridge.Account","title":"<code>Account</code>","text":"<p>\" Lichess account wrapper</p> Source code in <code>pcwawc/lichessbridge.py</code> <pre><code>class Account:\n    \"\"\" \" Lichess account wrapper\"\"\"\n\n    def __init__(self, adict):\n        self.adict = adict\n        self.id = adict[\"id\"]\n        if \"username\" in adict:\n            self.username = adict[\"username\"]\n        elif \"name\" in adict:\n            self.username = adict[\"name\"]\n        pass\n\n    def __str__(self):\n        text = \"%s - (%s)\" % (self.username, self.id)\n        return text\n</code></pre>"},{"location":"#pcwawc.lichessbridge.Game","title":"<code>Game</code>","text":"<p>               Bases: <code>Thread</code>, <code>Observable</code></p> <p>Lichess game</p> Source code in <code>pcwawc/lichessbridge.py</code> <pre><code>class Game(threading.Thread, Observable):\n    \"\"\"Lichess game\"\"\"\n\n    def __init__(self, lichess, game_id, debug=False, **kwargs):\n        super().__init__(**kwargs)\n        Observable.__init__(self)\n        self.debug = debug\n        self.game_id = game_id\n        self.lichess = lichess\n        self.account = lichess.getAccount()\n        self.client = lichess.client\n        self.stream = self.client.bots.stream_game_state(game_id)\n        self.current_state = None\n        self.isOn = False\n\n    def postChat(self, msg):\n        if self.debug:\n            print(\"Chat %s: %s\" % (self.game_id, msg))\n        self.client.bots.post_message(self.game_id, msg)\n        pass\n\n    def abort(self):\n        try:\n            self.client.bots.abort_game(self.game_id)\n            return True\n        except requests.exceptions.HTTPError as httpError:\n            return self.handle(httpError)\n\n    def resign(self):\n        try:\n            self.client.bots.resign_game(self.game_id)\n            return True\n        except requests.exceptions.HTTPError as httpError:\n            return self.handle(httpError)\n\n    def move(self, move):\n        try:\n            self.client.bots.make_move(self.game_id, move)\n            return True\n        except requests.exceptions.HTTPError as httpError:\n            return self.handle(httpError)\n\n    def handle(self, httpError):\n        if self.debug:\n            print(httpError)\n        return False\n\n    def stop(self):\n        self.isOn = False\n\n    def run(self):\n        if self.debug:\n            print(\n                \"started thread for user %s game %s\"\n                % (self.account.username, self.game_id)\n            )\n        self.isOn = True\n        # https://lichess.org/api#operation/botGameStream\n        for event in self.stream:\n            # stop if we are flagged to\n            if not self.isOn:\n                break\n            self.current_state = event\n            state = None\n            eventtype = event[\"type\"]\n            if self.debug:\n                print(eventtype, event)\n            if eventtype == \"gameFull\":\n                self.white = Account(event[\"white\"])\n                self.black = Account(event[\"black\"])\n                msg = \"white:%s black:%s\" % (self.white.username, self.black.username)\n                self.postChat(msg)\n                state = State(event[\"state\"])\n            elif eventtype == \"gameState\":\n                state = State(event)\n            if state is not None:\n                self.fire(state=state)\n        if self.debug:\n            print(\n                \"%s stopped thread for game %s\" % (self.account.username, self.game_id)\n            )\n</code></pre>"},{"location":"#pcwawc.lichessbridge.Lichess","title":"<code>Lichess</code>","text":"<p>Lichess adapter</p> Source code in <code>pcwawc/lichessbridge.py</code> <pre><code>class Lichess:\n    \"\"\"Lichess adapter\"\"\"\n\n    def __init__(self, tokenName=\"token\", debug=False):\n        self.debug = debug\n        token = self.getToken(tokenName)\n        if token is not None:\n            self.session = berserk.TokenSession(token)\n            self.client = berserk.Client(self.session)\n        else:\n            self.client = None\n        self.account = None\n\n    def getAccount(self):\n        if self.account is None and self.client is not None:\n            self.account = Account(self.client.account.get())\n        return self.account\n\n    def getToken(self, tokenname=\"token\"):\n        config = Config.default()\n        if not tokenname in config.config:\n            print(\"no token found in %s please add it\" % (config.configFile))\n            return None\n        return config.config[tokenname]\n\n    def pgnImport(self, pgn):\n        payload = {\"pgn\": pgn, \"analyse\": \"on\"}\n        res = requests.post(\"https://lichess.org/import\", data=payload)\n        print(res.url)\n        pass\n\n    def game(self, game_id):\n        game = lichess.api.game(game_id)\n        return game\n\n    def challenge(self, oponentUserName):\n        if self.debug:\n            print(\"challenge %s by %s\" % (self.getAccount().username, oponentUserName))\n        client = self.client\n        client.challenges.create(username=oponentUserName, rated=False)\n\n    def waitForChallenge(self, timeout=1000, pollInterval=0.5):\n        \"\"\"wait for a challend and return the corresponding game\"\"\"\n        # Stream whats happening and continue when we are challenged\n        in_game = False\n        client = self.client\n        account = self.getAccount()\n        if self.debug:\n            print(\n                \"%s waiting for challenge (max %d secs, polling every %.1f secs)\"\n                % (account.username, timeout, pollInterval)\n            )\n        while not in_game:\n            time.sleep(pollInterval)\n            timeout -= pollInterval\n            if timeout &lt;= 0:\n                raise Exception(\"time out waiting for challenge\")\n            for event in client.bots.stream_incoming_events():\n                eventtype = event[\"type\"]\n                if self.debug:\n                    print(eventtype, event)\n                if eventtype == \"gameStart\":\n                    game_id = event[\"game\"][\"id\"]\n                    in_game = True\n                    break\n                elif eventtype == \"challenge\":\n                    challenge = event[\"challenge\"]\n                    game_id = challenge[\"id\"]\n                    challenger = challenge[\"challenger\"]\n                    # don't try to play against myself\n                    if not challenger == account.username:\n                        client.bots.accept_challenge(game_id)\n                        in_game = True\n                    elif self.debug:\n                        print(\n                            \"%s avoiding to play against myself in game %s\"\n                            % (account.username, game_id)\n                        )\n        if self.debug:\n            print(\"The game %s has started!\" % (game_id))\n        return game_id\n</code></pre>"},{"location":"#pcwawc.lichessbridge.Lichess.waitForChallenge","title":"<code>waitForChallenge(timeout=1000, pollInterval=0.5)</code>","text":"<p>wait for a challend and return the corresponding game</p> Source code in <code>pcwawc/lichessbridge.py</code> <pre><code>def waitForChallenge(self, timeout=1000, pollInterval=0.5):\n    \"\"\"wait for a challend and return the corresponding game\"\"\"\n    # Stream whats happening and continue when we are challenged\n    in_game = False\n    client = self.client\n    account = self.getAccount()\n    if self.debug:\n        print(\n            \"%s waiting for challenge (max %d secs, polling every %.1f secs)\"\n            % (account.username, timeout, pollInterval)\n        )\n    while not in_game:\n        time.sleep(pollInterval)\n        timeout -= pollInterval\n        if timeout &lt;= 0:\n            raise Exception(\"time out waiting for challenge\")\n        for event in client.bots.stream_incoming_events():\n            eventtype = event[\"type\"]\n            if self.debug:\n                print(eventtype, event)\n            if eventtype == \"gameStart\":\n                game_id = event[\"game\"][\"id\"]\n                in_game = True\n                break\n            elif eventtype == \"challenge\":\n                challenge = event[\"challenge\"]\n                game_id = challenge[\"id\"]\n                challenger = challenge[\"challenger\"]\n                # don't try to play against myself\n                if not challenger == account.username:\n                    client.bots.accept_challenge(game_id)\n                    in_game = True\n                elif self.debug:\n                    print(\n                        \"%s avoiding to play against myself in game %s\"\n                        % (account.username, game_id)\n                    )\n    if self.debug:\n        print(\"The game %s has started!\" % (game_id))\n    return game_id\n</code></pre>"},{"location":"#pcwawc.lichessbridge.State","title":"<code>State</code>","text":"<p>Lichess state wrapper</p> Source code in <code>pcwawc/lichessbridge.py</code> <pre><code>class State:\n    \"\"\"Lichess state wrapper\"\"\"\n\n    def __init__(self, adict):\n        self.adict = adict\n        self.type = adict[\"type\"]\n        if self.type == \"gameState\":\n            self.moves = adict[\"moves\"]\n            self.wtime = adict[\"wtime\"]\n            self.btime = adict[\"btime\"]\n            self.winc = adict[\"winc\"]\n            self.binc = adict[\"binc\"]\n            self.wdraw = adict[\"wdraw\"]\n            self.bdraw = adict[\"bdraw\"]\n            self.moveList = self.moves.split()\n            self.moveIndex = len(self.moveList) - 1\n</code></pre>"},{"location":"#pcwawc.plotlib","title":"<code>plotlib</code>","text":""},{"location":"#pcwawc.plotlib.PlotLib","title":"<code>PlotLib</code>","text":"<p>               Bases: <code>object</code></p> <p>create matplotlib based multipage diagrams e.g. color channel histograms of images</p> Source code in <code>pcwawc/plotlib.py</code> <pre><code>class PlotLib(object):\n    \"\"\"\n    create matplotlib based multipage diagrams e.g. color channel histograms of images\n    \"\"\"\n\n    def __init__(self, title, pagesize, imagesPerPage=4):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.title = title\n        self.pagesize = pagesize\n        self.pagewidth, self.pageheight = self.pagesize\n        self.imagesPerPage = imagesPerPage\n        self.images = []\n\n    @staticmethod\n    def A4(turned=False):\n        # A4 canvas\n        fig_width_cm = 21  # A4 page size in cm\n        fig_height_cm = 29.7\n        inches_per_cm = 1 / 2.54  # Convert cm to inches\n        fig_width = fig_width_cm * inches_per_cm  # width in inches\n        fig_height = fig_height_cm * inches_per_cm  # height in inches\n        fig_size = [fig_width, fig_height]\n        if turned:\n            fig_size = fig_size[::-1]\n        return fig_size\n\n    def addPlot(self, image, imageTitle, xvalues=[], yvalues=[], isBGR=False):\n        rgb = image\n        if isBGR:\n            rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        self.images.append((rgb, imageTitle, xvalues, yvalues))\n\n    def plotImage(self, ax, image, imageTitle, thumbNailSize):\n        thumbNail = cv2.resize(image, (thumbNailSize, thumbNailSize))\n        ax.imshow(thumbNail)\n        ax.title.set_text(imageTitle)\n        ax.axis(\"off\")\n        pass\n\n    def plotChannel(self, img, ax, channel, prevAx=None):\n        cImg = img[:, :, channel]\n        ax.hist(np.ndarray.flatten(cImg), bins=256)\n        if prevAx is not None:\n            # Use matplotlib's sharex parameter instead of manually joining axes\n            ax.sharex(prevAx)\n            prevAx.set_xticklabels([])\n\n        ax.set_yticklabels([])\n        return ax\n\n    def plotHistogramm(self, image, axarr, rowIndex, colIndex):\n        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n        rgb = image\n        prevAx1 = self.plotChannel(hsv, axarr[rowIndex + 0, colIndex + 0], 0)  # hue\n        prevAx2 = self.plotChannel(\n            hsv, axarr[rowIndex + 0, colIndex + 1], 1\n        )  # saturation\n        prevAx3 = self.plotChannel(hsv, axarr[rowIndex + 0, colIndex + 2], 2)  # value\n        self.plotChannel(rgb, axarr[rowIndex + 1, colIndex + 0], 0, prevAx1)  # red\n        self.plotChannel(rgb, axarr[rowIndex + 1, colIndex + 1], 1, prevAx2)  # green\n        self.plotChannel(rgb, axarr[rowIndex + 1, colIndex + 2], 2, prevAx3)  # blue\n\n    def fixPath(self, path):\n        if not path.endswith(\".pdf\"):\n            path = path + \".pdf\"\n        return path\n\n    def addInfos(self, pdf, infos):\n        pdfinfo = pdf.infodict()\n        for key, info in infos.items():\n            pdfinfo[key] = info\n\n    def pixel(self, fig, inch):\n        return int(inch * fig.dpi)\n\n    def startPDF(self, path):\n        path = self.fixPath(path)\n        return PdfPages(path)\n\n    def finishPDFPage(self, pdf):\n        plt.tight_layout()\n        pdf.savefig()\n        plt.close()\n\n    def finishPDF(self, pdf, infos={}):\n        self.addInfos(pdf, infos)\n\n    def createHistogramPDF(self, path, plotType=PlotType.HISTOGRAMM, infos={}):\n        imageIndex = 0\n        with self.startPDF(path) as pdf:\n            self.pages = len(self.images) // self.imagesPerPage\n            for page in range(self.pages + 1):\n                colTitles = [\"image\", \"\", \"hue/blue\", \"saturation/green\", \"value/red\"]\n                if plotType == PlotType.PLOT:\n                    colTitles = [\"image\", \"\", \"diffSum\", \"\"]\n                cols = len(colTitles)\n                rows = self.imagesPerPage * 2\n                fig, axarr = plt.subplots(rows, cols, figsize=self.pagesize)\n                if fig is None:\n                    pass\n                for ax, colTitle in zip(axarr[0], colTitles):\n                    ax.set_title(colTitle)\n                thumbNailSize = 512  # self.pixel(fig,self.pageheight)\n                for pageImageIndex in range(0, self.imagesPerPage):\n                    if imageIndex &lt; len(self.images):\n                        image, imageTitle, xvalues, yvalues = self.images[imageIndex]\n                        # see https://matplotlib.org/3.1.1/tutorials/intermediate/tight_layout_guide.html#sphx-glr-tutorials-intermediate-tight-layout-guide-py\n                        axImage = plt.subplot2grid(\n                            (rows, cols), (pageImageIndex * 2, 0), colspan=2, rowspan=2\n                        )\n                        self.plotImage(axImage, image, imageTitle, thumbNailSize)\n                        if plotType == PlotType.HISTOGRAMM:\n                            self.plotHistogramm(image, axarr, pageImageIndex * 2, 2)\n                        else:\n                            axPlot = plt.subplot2grid(\n                                (rows, cols),\n                                (pageImageIndex * 2, 2),\n                                colspan=2,\n                                rowspan=2,\n                            )\n                            axPlot.plot(xvalues, yvalues)\n\n                    else:\n                        for col in range(cols):\n                            axarr[pageImageIndex * 2, col].remove()\n                            axarr[pageImageIndex * 2 + 1, col].remove()\n                    imageIndex = imageIndex + 1\n                # plt.title(\"page %d\" %(page))\n                self.finishPDFPage(pdf)\n            self.finishPDF(pdf, infos)\n</code></pre>"},{"location":"#pcwawc.plotlib.PlotLib.__init__","title":"<code>__init__(title, pagesize, imagesPerPage=4)</code>","text":"<p>Constructor</p> Source code in <code>pcwawc/plotlib.py</code> <pre><code>def __init__(self, title, pagesize, imagesPerPage=4):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.title = title\n    self.pagesize = pagesize\n    self.pagewidth, self.pageheight = self.pagesize\n    self.imagesPerPage = imagesPerPage\n    self.images = []\n</code></pre>"},{"location":"#pcwawc.plotlib.PlotType","title":"<code>PlotType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>kind of Plot</p> Source code in <code>pcwawc/plotlib.py</code> <pre><code>class PlotType(IntEnum):\n    \"\"\"kind of Plot\"\"\"\n\n    HISTOGRAMM = 0\n    PLOT = 1\n</code></pre>"},{"location":"#pcwawc.runningstats","title":"<code>runningstats</code>","text":""},{"location":"#pcwawc.runningstats.ColorStats","title":"<code>ColorStats</code>","text":"<p>calculate the RunningStats for 3 color channels like RGB or HSV simultaneously</p> Source code in <code>pcwawc/runningstats.py</code> <pre><code>@implementer(IStats)\nclass ColorStats:\n    \"\"\"calculate the RunningStats for 3 color channels like RGB or HSV simultaneously\"\"\"\n\n    def __init__(self):\n        self.c1Stats = RunningStats()\n        self.c2Stats = RunningStats()\n        self.c3Stats = RunningStats()\n\n    def clear(self):\n        self.c1Stats.clear()\n        self.c2Stats.clear()\n        self.c3Stats.clear()\n\n    def push(self, c1, c2, c3):\n        self.c1Stats.push(c1)\n        self.c2Stats.push(c2)\n        self.c3Stats.push(c3)\n\n    def mean(self):\n        return (self.c1Stats.mean(), self.c2Stats.mean(), self.c3Stats.mean())\n\n    def variance(self):\n        return (\n            self.c1Stats.variance(),\n            self.c2Stats.variance(),\n            self.c3Stats.variance(),\n        )\n\n    def standard_deviation(self):\n        return (\n            self.c1Stats.standard_deviation(),\n            self.c2Stats.standard_deviation(),\n            self.c3Stats.standard_deviation(),\n        )\n\n    @staticmethod\n    def square(value):\n        return value * value\n\n    def colorKey(self):\n        other = ColorStats()\n        other.push(0, 0, 0)\n        return ColorStats.distance(self, other)\n\n    def rgbColorKey(self):\n        from pcwawc import ciede2000\n\n        value = ciede2000.ciede2000FromRGB(self.mean(), (0, 0, 0))\n        return value\n\n    @staticmethod\n    def distance(this, other):\n        \"\"\"simple eucledian color distance see e.g. https://en.wikipedia.org/wiki/Color_difference\"\"\"\n        c1s = ColorStats.square(this.c1Stats.mean() - other.c1Stats.mean())\n        c2s = ColorStats.square(this.c2Stats.mean() - other.c2Stats.mean())\n        c3s = ColorStats.square(this.c3Stats.mean() - other.c3Stats.mean())\n        dist = c1s + c2s + c3s\n        return dist\n</code></pre>"},{"location":"#pcwawc.runningstats.ColorStats.distance","title":"<code>distance(this, other)</code>  <code>staticmethod</code>","text":"<p>simple eucledian color distance see e.g. https://en.wikipedia.org/wiki/Color_difference</p> Source code in <code>pcwawc/runningstats.py</code> <pre><code>@staticmethod\ndef distance(this, other):\n    \"\"\"simple eucledian color distance see e.g. https://en.wikipedia.org/wiki/Color_difference\"\"\"\n    c1s = ColorStats.square(this.c1Stats.mean() - other.c1Stats.mean())\n    c2s = ColorStats.square(this.c2Stats.mean() - other.c2Stats.mean())\n    c3s = ColorStats.square(this.c3Stats.mean() - other.c3Stats.mean())\n    dist = c1s + c2s + c3s\n    return dist\n</code></pre>"},{"location":"#pcwawc.runningstats.IStats","title":"<code>IStats</code>","text":"<p>               Bases: <code>Interface</code></p> <p>statistics interface</p> Source code in <code>pcwawc/runningstats.py</code> <pre><code>class IStats(Interface):\n    \"\"\"statistics interface\"\"\"\n\n    def push(self, value):\n        \"\"\"push a value to the statistics\"\"\"\n        pass\n\n    def mean(self):\n        \"\"\"get the mean value\"\"\"\n        pass\n</code></pre>"},{"location":"#pcwawc.runningstats.IStats.mean","title":"<code>mean()</code>","text":"<p>get the mean value</p> Source code in <code>pcwawc/runningstats.py</code> <pre><code>def mean(self):\n    \"\"\"get the mean value\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.runningstats.IStats.push","title":"<code>push(value)</code>","text":"<p>push a value to the statistics</p> Source code in <code>pcwawc/runningstats.py</code> <pre><code>def push(self, value):\n    \"\"\"push a value to the statistics\"\"\"\n    pass\n</code></pre>"},{"location":"#pcwawc.runningstats.MinMaxStats","title":"<code>MinMaxStats</code>","text":"<p>               Bases: <code>RunningStats</code>, <code>MinMaxMixin</code></p> <p>running statistics with minimum and maximum</p> Source code in <code>pcwawc/runningstats.py</code> <pre><code>class MinMaxStats(RunningStats, MinMaxMixin):\n    \"\"\"running statistics with minimum and maximum\"\"\"\n\n    def __init__(self):\n        super(MinMaxStats, self).__init__()\n        super().initMinMax()\n\n    def push(self, value):\n        super().push(value)\n        super().pushMinMax(value)\n\n    def clear(self):\n        super().clear()\n        super().initMinMax()\n\n    def formatMinMax(self, formatR=\"%d: %.1f \u00b1 %.1f\", formatM=\" %.1f - %.1f\"):\n        text = super().format(formatR)\n        if self.n &gt; 0:\n            text += super().formatMinMax(formatM)\n        return text\n</code></pre>"},{"location":"#pcwawc.runningstats.MovingAverage","title":"<code>MovingAverage</code>","text":"<p>calculate a moving average</p> Source code in <code>pcwawc/runningstats.py</code> <pre><code>@implementer(IStats)\nclass MovingAverage:\n    \"\"\"calculate a moving average\"\"\"\n\n    def __init__(self, maxlen):\n        self.maxlen = maxlen\n        self.d = deque(maxlen=maxlen)\n        self.sum = 0\n        self.n = 0\n        self.value = None\n\n    def push(self, value):\n        \"\"\"recalculate the Moving Average based on a new value\"\"\"\n        self.value = value\n        self.sum += value\n        if self.n &lt; self.maxlen:\n            self.n += 1\n        else:\n            self.sum -= self.d.popleft()\n        self.d.append(value)\n\n    def gradient(self):\n        if self.n &gt;= 2:\n            g = (self.d[self.n - 1] - self.d[0]) / (self.n - 1)\n            return g\n        else:\n            return 0\n\n    def mean(self):\n        if self.n == 0:\n            return None\n        return self.sum / self.n\n\n    def __str__(self):\n        return self.format()\n\n    def format(self, formatM=\"%.1f\"):\n        text = formatM % self.mean()\n        return text\n</code></pre>"},{"location":"#pcwawc.runningstats.MovingAverage.push","title":"<code>push(value)</code>","text":"<p>recalculate the Moving Average based on a new value</p> Source code in <code>pcwawc/runningstats.py</code> <pre><code>def push(self, value):\n    \"\"\"recalculate the Moving Average based on a new value\"\"\"\n    self.value = value\n    self.sum += value\n    if self.n &lt; self.maxlen:\n        self.n += 1\n    else:\n        self.sum -= self.d.popleft()\n    self.d.append(value)\n</code></pre>"},{"location":"#pcwawc.runningstats.RunningStats","title":"<code>RunningStats</code>","text":"<p>calculate mean, variance and standard deviation in one pass using Welford's algorithm</p> Source code in <code>pcwawc/runningstats.py</code> <pre><code>@implementer(IStats)\nclass RunningStats:\n    \"\"\"calculate mean, variance and standard deviation in one pass using Welford's algorithm\"\"\"\n\n    def __init__(self):\n        self.n = 0\n        self.old_m = 0\n        self.new_m = 0\n        self.old_s = 0\n        self.new_s = 0\n\n    def clear(self):\n        self.n = 0\n\n    def push(self, xvalue):\n        self.n += 1\n        x = float(xvalue)\n\n        if self.n == 1:\n            self.old_m = self.new_m = x\n            self.old_s = 0\n        else:\n            self.new_m = self.old_m + (x - self.old_m) / self.n\n            self.new_s = self.old_s + (x - self.old_m) * (x - self.new_m)\n\n            self.old_m = self.new_m\n            self.old_s = self.new_s\n\n    def mean(self):\n        return self.new_m if self.n else 0.0\n\n    def variance(self):\n        return self.new_s / (self.n - 1) if self.n &gt; 1 else 0.0\n\n    def standard_deviation(self):\n        return math.sqrt(self.variance())\n\n    def __str__(self):\n        return self.format()\n\n    def format(self, formatS=\"%d: %.1f \u00b1 %.1f\"):\n        m = self.mean()\n        s = self.standard_deviation()\n        text = formatS % (self.n, m, s)\n        return text\n</code></pre>"},{"location":"#pcwawc.simpledetector","title":"<code>simpledetector</code>","text":"<p>Created on 2019-12-07</p> <p>@author: tk</p>"},{"location":"#pcwawc.simpledetector.ImageChange","title":"<code>ImageChange</code>","text":"<p>detect change of a single image</p> Source code in <code>pcwawc/simpledetector.py</code> <pre><code>class ImageChange:\n    \"\"\"detect change of a single image\"\"\"\n\n    thresh = 150\n    gradientDelta = 0.725\n    averageWindow = 4\n\n    def __init__(self):\n        self.stats = MinMaxStats()\n        self.movingAverage = MovingAverage(ImageChange.averageWindow)\n        self.clear()\n\n    def clear(self, newState=ChangeState.CALIBRATING):\n        self.cbReferenceBW = None\n        self.stats.clear()\n        self.changeState = newState\n        self.stableCounter = 0\n\n    def transitionToPreMove(self):\n        self.changeState = ChangeState.PRE_MOVE\n        self.minInMove = self.pixelChanges\n        self.maxInMove = self.pixelChanges\n\n    def check(self, cbImage):\n        self.makeGray(cbImage)\n        self.calcDifference()\n        if self.hasReference:\n            self.calcPixelChanges()\n\n    def makeGray(self, cbImage):\n        self.cbImage = cbImage\n        image = cbImage.image\n        imageGray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        self.cbImageGray = ChessBoardImage(\n            cv2.cvtColor(imageGray, cv2.COLOR_GRAY2BGR), \"gray\"\n        )\n        # @TODO Make the treshold 150 configurable\n        thresh = ImageChange.thresh\n        (thresh, self.imageBW) = cv2.threshold(imageGray, thresh, 255, cv2.THRESH_TRUNC)\n        self.cbImageBW = ChessBoardImage(\n            cv2.cvtColor(self.imageBW, cv2.COLOR_GRAY2BGR), \"bw\"\n        )\n\n    def calcDifference(self):\n        self.updateReference(self.cbImageBW)\n        self.cbDiffImage = self.cbImageBW.diffBoardImage(self.cbReferenceBW)\n\n    def updateReference(self, cbImageBW, force=False):\n        self.hasReference = not self.cbReferenceBW is None\n        if not self.hasReference or force:\n            self.cbReferenceBW = cbImageBW\n\n    def calcPixelChanges(self):\n        self.pixelChanges = (\n            cv2.norm(self.cbImageBW.image, self.cbReferenceBW.image, cv2.NORM_L1)\n            / self.cbImageBW.pixels\n        )\n        self.movingAverage.push(self.pixelChanges)\n        self.stats.push(self.pixelChanges)\n\n    def isStable(self):\n        self.delta = abs(self.movingAverage.gradient())\n        stable = self.delta &lt; ImageChange.gradientDelta\n        if stable:\n            self.stableCounter += 1\n        else:\n            self.stableCounter = 0\n        return stable\n\n    def __str__(self):\n        delta = self.movingAverage.gradient()\n        text = \"%14s: %5.1f \u0394: %5.1f \u00d8: %s/%s, \u03a3: %d\" % (\n            self.changeState.title(),\n            self.pixelChanges,\n            delta,\n            self.movingAverage.format(formatM=\"%5.1f\"),\n            self.stats.formatMinMax(\n                formatR=\"%4d: %5.1f \u00b1 %5.1f\", formatM=\" %5.1f - %5.1f\"\n            ),\n            self.cbImageBW.pixels,\n        )\n        return text\n</code></pre>"},{"location":"#pcwawc.simpledetector.Simple8x8Detector","title":"<code>Simple8x8Detector</code>","text":"<p>               Bases: <code>SimpleDetector</code></p> <p>a simple treshold per field detector</p> Source code in <code>pcwawc/simpledetector.py</code> <pre><code>@implementer(IMoveDetector)\nclass Simple8x8Detector(SimpleDetector):\n    \"\"\"a simple treshold per field detector\"\"\"\n\n    # construct me\n    def __init__(self):\n        super().__init__()\n\n    def setup(self, name, vision):\n        super().setup(name, vision)\n        self.board = self.vision.board\n        self.imageChanges = {}\n        for square in self.board.genSquares():\n            self.imageChanges[square.an] = ImageChange()\n\n    def onChessBoardImage(self, imageEvent):\n        super().onChessBoardImage(imageEvent)\n        cbImageSet = imageEvent.cbImageSet\n        vision = cbImageSet.vision\n        ic = self.imageChange\n        cs = ic.changeState\n        if vision.warp.warping and cs == ChangeState.PRE_MOVE:\n            self.calcChanges(cbImageSet)\n            if ic.delta &lt; ImageChange.gradientDelta / 2:\n                ic.updateReference(ic.cbImageBW, force=True)\n\n    def calcChanges(self, cbImageSet):\n        cbWarped = cbImageSet.cbWarped\n        # TODO only do once ...\n        self.board.divideInSquares(cbWarped.width, cbWarped.height)\n        # calculate pixelChanges per square based on parts of the bigger images created by the super class\n        for square in self.board.genSquares():\n            ic = self.imageChanges[square.an]\n            ic.cbImageBW = ChessBoardImage(\n                square.getSquareImage(self.imageChange.cbImageBW), square.an\n            )\n            ic.updateReference(ic.cbImageBW)\n            if ic.hasReference:\n                ic.calcPixelChanges()\n                # if self.vision.debug:\n                # print (\"%4d %s: %s\" % (cbImageSet.frameIndex,square.an,ic))\n\n    def showDebug(self, limit=6):\n        changesByValue = OrderedDict(\n            sorted(\n                self.imageChanges.items(), key=lambda x: x[1].pixelChanges, reverse=True\n            )\n        )\n        ans = list(changesByValue.keys())[:limit]\n        for an in ans:\n            ic = self.imageChanges[an]\n            print(\"%s: %s\" % (an, ic))\n        pass\n\n    def onMoveDetected(self, cbImageSet):\n        self.calcChanges(cbImageSet)\n        changesByValue = OrderedDict(\n            sorted(\n                self.imageChanges.items(), key=lambda x: x[1].pixelChanges, reverse=True\n            )\n        )\n        keys = list(changesByValue.keys())\n        for changeIndex in range(4):\n            change = (keys[0], keys[changeIndex + 1])\n            if self.vision.debug:\n                print(\n                    \"frame %4d: potential move for squares %s\"\n                    % (cbImageSet.frameIndex, str(change))\n                )\n            move = self.vision.board.changeToMove(change)\n            # did we find a move?\n            if move is None:\n                if self.vision.debug:\n                    print(\"change %s has no valid move\" % (str(change)))\n            else:\n                break\n        if self.debug:\n            self.showDebug()\n        if move is None:\n            if self.vision.debug:\n                print(\n                    \"frame %4d: giving up on move detection\" % (cbImageSet.frameIndex)\n                )\n        else:\n            super().onMoveDetected(cbImageSet)\n            for square in self.board.genSquares():\n                ic = self.imageChanges[square.an]\n                ic.clear()\n            self.fire(move=move)\n</code></pre>"},{"location":"#pcwawc.simpledetector.SimpleDetector","title":"<code>SimpleDetector</code>","text":"<p>               Bases: <code>Observable</code></p> <p>a simple treshold detector</p> Source code in <code>pcwawc/simpledetector.py</code> <pre><code>@implementer(IMoveDetector)\nclass SimpleDetector(Observable):\n    \"\"\"a simple treshold detector\"\"\"\n\n    calibrationWindow = 3\n\n    def __init__(self):\n        \"\"\"construct me\"\"\"\n        # make me observable\n        super(SimpleDetector, self).__init__()\n        self.debug = False\n        self.frameDebug = False\n        pass\n\n    def setup(self, name, vision):\n        self.name = name\n        self.vision = vision\n        self.imageChange = ImageChange()\n\n    def onChessBoardImage(self, imageEvent):\n        cbImageSet = imageEvent.cbImageSet\n        vision = cbImageSet.vision\n        if vision.warp.warping:\n            cbWarped = cbImageSet.cbWarped\n            start = timer()\n            self.imageChange.check(cbWarped)\n            ic = self.imageChange\n            endt = timer()\n            cbImageSet.cbDebug = cbImageSet.debugImage2x2(\n                cbWarped, ic.cbImageGray, ic.cbImageBW, ic.cbDiffImage\n            )\n            if self.imageChange.hasReference:\n                self.updateState(cbImageSet)\n                if self.frameDebug:\n                    print(\n                        \"Frame %5d %.3f s:%s\"\n                        % (cbImageSet.frameIndex, endt - start, ic)\n                    )\n\n    def updateState(self, cbImageSet):\n        ic = self.imageChange\n        ics = ic.changeState\n        if ics == ChangeState.CALIBRATING:\n            # leave calibrating when enough stable values are available\n            if ic.isStable() and ic.stableCounter &gt;= SimpleDetector.calibrationWindow:\n                ic.transitionToPreMove()\n        elif ics == ChangeState.PRE_MOVE:\n            if not ic.isStable():\n                ic.changeState = ChangeState.IN_MOVE\n            else:\n                ic.transitionToPreMove()\n        elif ics == ChangeState.IN_MOVE:\n            ic.maxInMove = max(ic.maxInMove, ic.pixelChanges)\n            peak = ic.maxInMove - ic.minInMove\n            dist = ic.pixelChanges - ic.minInMove\n            if peak &gt; 0:\n                relativePeak = dist / peak\n                if ic.isStable():\n                    if self.frameDebug:\n                        print(\"%.1f %%\" % (relativePeak * 100))\n                    # @TODO make configurable\n                    if relativePeak &lt; 0.16 or (relativePeak &lt; 0.35 and ic.delta &lt; 0.1):\n                        self.onMoveDetected(cbImageSet)\n\n    def onMoveDetected(self, cbImageSet):\n        self.imageChange.clear()\n        pass\n</code></pre>"},{"location":"#pcwawc.simpledetector.SimpleDetector.__init__","title":"<code>__init__()</code>","text":"<p>construct me</p> Source code in <code>pcwawc/simpledetector.py</code> <pre><code>def __init__(self):\n    \"\"\"construct me\"\"\"\n    # make me observable\n    super(SimpleDetector, self).__init__()\n    self.debug = False\n    self.frameDebug = False\n    pass\n</code></pre>"},{"location":"#pcwawc.video","title":"<code>video</code>","text":""},{"location":"#pcwawc.video.Video","title":"<code>Video</code>","text":"<p>Video handling e.g. recording/writing</p> Source code in <code>pcwawc/video.py</code> <pre><code>class Video:\n    \"\"\"Video handling e.g. recording/writing\"\"\"\n\n    @staticmethod\n    def getVideo():\n        video = Video()\n        video.headless = Environment.inContinuousIntegration()\n        return video\n\n    # construct me with no parameters\n    def __init__(self, title=\"frame\"):\n        self.title = title\n        self.cap = None\n        self.frames = 0\n        self.ispaused = False\n        # current Frame\n        self.frame = None\n        self.processedFrame = None\n        self.maxFrames = sys.maxsize\n        # still image ass video feature for jpg\n        self.autoPause = False\n        self.fpsCheck = None\n        self.debug = False\n        self.headless = False\n        pass\n\n    # check whether s is an int\n    @staticmethod\n    def is_int(s):\n        try:\n            int(s)\n            return True\n        except ValueError:\n            return False\n\n    @staticmethod\n    def title(device):\n        if not Video.is_int(device):\n            deviceTitle = os.path.basename(device)\n        else:\n            deviceTitle = \"camera %s\" % (device)\n        return deviceTitle\n\n    # return if video is paused\n    def paused(self):\n        return self.ispaused\n\n    # pause the video\n    def pause(self, ispaused):\n        self.ispaused = ispaused\n\n    # capture from the given device\n    def capture(self, device):\n        if Video.is_int(device):\n            self.device = int(device)\n        else:\n            self.device = device\n            self.open(device)\n            if device.endswith(\".jpg\"):\n                self.maxFrames = 1\n                self.autoPause = True\n        self.setup(cv2.VideoCapture(self.device))\n\n    def setup(self, cap):\n        \"\"\"setup the capturing from the given device\"\"\"\n        self.width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n        self.height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n        self.fps = int(cap.get(cv2.CAP_PROP_FPS))\n        self.cap = cap\n        self.fpsCheck = FPSCheck()\n        self.fpsCheck.start()\n\n    def checkFilePath(self, filePath, raiseException=True):\n        ok = os.path.exists(filePath)\n        if raiseException and not ok:\n            raise Exception(\"file %s does not exist\" % (filePath))\n        return ok\n\n    # capture from the given video filePath\n    def open(self, filePath):\n        self.checkFilePath(filePath)\n        self.setup(cv2.VideoCapture(filePath))\n\n    def showImage(self, image, title: str, keyCheck: bool = True, keyWait: int = 5):\n        \"\"\"\n        show the image with the given title\n\n        Args:\n            image: the image to show\n            title(str): the title of the image\n            keyCheck(bool): wait for a a key stroke before continuing?\n            keyWait(int): maximum number of seconds to wait for a key stroke\n        \"\"\"\n        if not threading.current_thread() is threading.main_thread():\n            if self.debug:\n                print(\"can't show image %s since not on mainthread\" % (title))\n            return True\n        if self.headless:\n            return True\n        cv2.imshow(title, image)\n        if keyCheck:\n            return not cv2.waitKey(keyWait) &amp; 0xFF == ord(\"q\")\n        else:\n            return True\n\n    def showAndWriteImage(\n        self, image, title, path=\"/tmp/\", imageFormat=\".jpg\", keyCheck=True, keyWait=5\n    ):\n        result = self.showImage(image, title, keyCheck, keyWait)\n        if image is not None:\n            cv2.imshow(title, image)\n            cv2.imwrite(path + title + imageFormat, image)\n        return result\n\n    # encode the image\n    def imencode(self, frame, imgformat=\".jpg\"):\n        # encode the frame in JPEG format\n        (flag, encodedImage) = cv2.imencode(imgformat, frame)\n        return flag, encodedImage\n\n    # return a video frame as a jpg image\n    def readJpgImage(self, show=False, postProcess=None):\n        ret, frame, quitWanted = self.readFrame(show, postProcess)\n        encodedImage = None\n        # ensure the frame was read\n        if ret:\n            (flag, encodedImage) = self.imencode(frame)\n            # ensure the frame was successfully encoded\n            if not flag:\n                ret = False\n        return ret, encodedImage, quitWanted\n\n    # return a video frame as a numpy array\n    def readFrame(self, show=False, postProcess=None):\n        # when pausing repeat previous frame\n        if self.ispaused:\n            # simply return the current frame again\n            ret = self.frame is not None\n        else:\n            ret, self.frame = self.cap.read()\n        quitWanted = False\n        if ret == True:\n            if not self.ispaused:\n                self.frames = self.frames + 1\n                if self.frames &gt;= self.maxFrames and self.autoPause:\n                    self.ispaused = True\n                self.fpsCheck.update()\n            if not postProcess is None:\n                try:\n                    self.processedFrame = postProcess(self.frame)\n                except BaseException as e:\n                    # @TODO log exception\n                    print(\"processing error \" + str(e))\n                    self.processedFrame = self.frame\n            else:\n                self.processedFrame = self.frame\n            if show:\n                quitWanted = not self.showImage(self.frame, self.title)\n        return ret, self.processedFrame, quitWanted\n\n    # play the given capture\n    def play(self):\n        while self.cap.isOpened():\n            ret, frame, quitWanted = self.readFrame(True)\n            if ret == True:\n                if quitWanted:\n                    break\n                if frame is None:\n                    # TODO decide whether to log a warning here\n                    pass\n            else:\n                break\n        self.close()\n\n    def fileTimeStamp(self):\n        return self.timeStamp(separator=\"_\", timeseparator=\"\")\n\n    def timeStamp(self, separator=\" \", timeseparator=\":\"):\n        return strftime(\n            \"%Y-%m-%d\" + separator + \"%H\" + timeseparator + \"%M\" + timeseparator + \"%S\"\n        )\n\n    def close(self):\n        if self.cap is not None:\n            self.cap.release()\n        cv2.destroyAllWindows()\n\n    def checkCap(self):\n        if self.cap is None:\n            raise \"Capture is not initialized\"\n\n    # get a still image\n    def still(\n        self,\n        prefix,\n        imgformat=\"jpg\",\n        close=True,\n        printHints=True,\n        show=False,\n        postProcess=None,\n    ):\n        filename = \"%s%s.%s\" % (prefix, self.fileTimeStamp(), imgformat)\n        return self.still2File(\n            filename,\n            format=format,\n            close=close,\n            printHints=printHints,\n            show=show,\n            postProcess=postProcess,\n        )\n\n    # get a still image\n    def still2File(\n        self,\n        filename,\n        format=\"jpg\",\n        close=True,\n        printHints=True,\n        show=False,\n        postProcess=None,\n    ):\n        self.checkCap()\n        ret = False\n        frame = None\n        if self.cap.isOpened():\n            ret, frame, quitWanted = self.readFrame(show, postProcess)\n            if ret == True:\n                if printHints:\n                    print(\"capture %s with %dx%d\" % (filename, self.width, self.height))\n                self.writeImage(frame, filename)\n            if close:\n                self.close()\n        return ret, frame\n\n    # read an image\n    def readImage(self, filePath):\n        self.checkFilePath(filePath)\n        image = cv2.imread(filePath, 1)\n        return image\n\n    def writeImage(self, image, filepath):\n        cv2.imwrite(filepath, image)\n\n    def prepareRecording(self, filename, width, height, fps=None):\n        self.checkCap()\n        if fps is None:\n            fps = self.fps\n        # Define the codec and create VideoWriter object\n        fourcc = cv2.VideoWriter_fourcc(*\"XVID\")\n        out = cv2.VideoWriter(filename, fourcc, fps, (width, height))\n        return out\n\n    # record the capture to a file with the given prefix using a timestamp\n    def record(self, prefix, printHints=True, fps=None):\n        filename = \"%s%s.avi\" % (prefix, self.timeStamp())\n        out = self.prepareRecording(filename, self.width, self.height, fps)\n\n        if printHints:\n            print(\n                \"recording %s with %dx%d at %d fps press q to stop recording\"\n                % (filename, self.width, self.height, self.fps)\n            )\n\n        while self.cap.isOpened():\n            ret, frame, quitWanted = self.readFrame(True)\n            if ret == True:\n                # flip the frame\n                # frame = cv2.flip(frame,0)\n                if quitWanted:\n                    break\n                # write the  frame\n                out.write(frame)\n            else:\n                break\n\n        # Release everything if job is finished\n        self.close()\n        out.release()\n        cv2.destroyAllWindows()\n        if printHints:\n            print(\"finished\")\n\n    # https://stackoverflow.com/a/22921648/1497139\n    def createBlank(self, width, height, rgb_color=(0, 0, 0)):\n        \"\"\"Create new image(numpy array) filled with certain color in RGB\"\"\"\n        # Create black blank image\n        image = self.getEmptyImage4WidthAndHeight(width, height, 3)\n\n        # Since OpenCV uses BGR, convert the color first\n        color = tuple(reversed(rgb_color))\n        # Fill image with color\n        image[:] = color\n\n        return image\n\n    def getEmptyImage4WidthAndHeight(self, w, h, channels):\n        \"\"\"get an empty image with the given width height and channels\"\"\"\n        emptyImage = np.zeros((h, w, channels), np.uint8)\n        return emptyImage\n\n    def getEmptyImage(self, image, channels=1):\n        \"\"\"prepare a trapezoid/polygon mask to focus on the square chess field seen as a trapezoid\"\"\"\n        h, w = image.shape[:2]\n        emptyImage = self.getEmptyImage4WidthAndHeight(w, h, channels)\n        return emptyImage\n\n    def maskImage(self, image, mask):\n        \"\"\"return the masked image that filters with the given mask\"\"\"\n        masked = cv2.bitwise_and(image, image, mask=mask)\n        return masked\n\n    # was: http://www.robindavid.fr/opencv-tutorial/chapter5-line-edge-and-contours-detection.html\n    # is: https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghlines/py_houghlines.html\n    # https://docs.opencv.org/3.4/d9/db0/tutorial_hough_lines.html\n    def houghTransform(self, image):\n        \"\"\"Performs an Hough Transform to given image.\n\n        Returns: lines\"\"\"\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        edges = cv2.Canny(gray, 50, 150, apertureSize=3)\n        lines = cv2.HoughLines(edges, 1, np.pi / 180, 200)\n        return lines\n\n    def houghTransformP(self, image):\n        \"\"\"Performs a probabilistic Hough Transform to given image.\n\n        Returns: lines\"\"\"\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        edges = cv2.Canny(gray, 50, 150, apertureSize=3)\n        h, w = image.shape[:2]\n        minLineLength = h / 16\n        maxLineGap = h / 24\n        lines = cv2.HoughLinesP(edges, 1, np.pi / 180, 100, minLineLength, maxLineGap)\n        return lines\n\n    def drawTrapezoid(self, image, points, color):\n        \"\"\"loop over the given points and draw them on the image\"\"\"\n        if points is None:\n            return\n        prev = None\n        # if there is exactly four points then close the loop\n        if len(points) == 4:\n            points.append(points[0])\n        for x, y in points:\n            cv2.circle(image, (x, y), 10, color, -1)\n            if prev is not None:\n                cv2.line(image, (x, y), prev, color, 3, cv2.LINE_AA)\n            prev = (x, y)\n\n    def drawCircle(self, image, center, radius=10, color=(0, 255, 0), thickness=1):\n        cv2.circle(image, center, radius, color=color, thickness=thickness)\n\n    def drawRectangle(self, image, pt1, pt2, color=(0, 255, 0), thickness=1):\n        cv2.rectangle(image, pt1, pt2, color, thickness)\n\n    def drawPolygon(self, image, polygon, color):\n        \"\"\"draw the given polygon onto the given image with the given color\"\"\"\n        cv2.fillConvexPoly(image, polygon, color)\n\n    #  https://docs.opencv.org/4.1.2/d9/db0/tutorial_hough_lines.html\n    def drawLines(self, image, lines):\n        height, width = image.shape[:2]\n        for i in range(0, len(lines)):\n            rho = lines[i][0][0]\n            theta = lines[i][0][1]\n            a = math.cos(theta)\n            b = math.sin(theta)\n            x0 = a * rho\n            y0 = b * rho\n            pt1 = (int(x0 + width * (-b)), int(y0 + height * (a)))\n            pt2 = (int(x0 - width * (-b)), int(y0 - height * (a)))\n            cv2.line(image, pt1, pt2, (0, 0, 255), 3, cv2.LINE_AA)\n\n    def rotate(self, image, angle, center=None, scale=1.0):\n        # grab the dimensions of the image\n        (h, w) = image.shape[:2]\n\n        # if the center is None, initialize it as the center of\n        # the image\n        if center is None:\n            center = (w // 2, h // 2)\n\n        # perform the rotation (clockwise)\n        M = cv2.getRotationMatrix2D(center, -angle, scale)\n        rotated = cv2.warpAffine(image, M, (w, h))\n\n        # return the rotated image\n        return rotated\n\n    def warp(self, image, pts, squared=True):\n        \"\"\"apply the four point transform to obtain a birds eye view of the given image\"\"\"\n        warped = perspective.four_point_transform(image, pts)\n        if squared:\n            height, width = warped.shape[:2]\n            side = min(width, height)\n            warped = cv2.resize(warped, (side, side))\n        return warped\n\n    def as2x2(self, row1col1, row1col2, row2col1, row2col2, downScale=2):\n        height, width = row1col1.shape[:2]\n        image1, image2, image3, image4 = row1col1, row1col2, row2col1, row2col2\n        if downScale &gt; 1:\n            image1 = cv2.resize(image1, (width // downScale, height // downScale))\n            image2 = cv2.resize(image2, (width // downScale, height // downScale))\n            image3 = cv2.resize(image3, (width // downScale, height // downScale))\n            image4 = cv2.resize(image4, (width // downScale, height // downScale))\n\n        combined1 = np.concatenate((image1, image2), axis=0)\n        combined2 = np.concatenate((image3, image4), axis=0)\n        combined = np.concatenate((combined1, combined2), axis=1)\n        return combined\n\n    @staticmethod\n    def getSubRect(image, rect):\n        x, y, w, h = rect\n        return image[y : y + h, x : x + w]\n\n    # get the intensity sum of a hsv image\n    def sumIntensity(self, image):\n        h, s, v = cv2.split(image)\n        height, width = image.shape[:2]\n        sumResult = np.sum(v)\n        return sumResult\n\n    # add a timeStamp to the given frame fontScale 1.0\n    def addTimeStamp(\n        self,\n        frame,\n        withFrames=True,\n        withFPS=True,\n        fontBGRColor=(0, 255, 0),\n        fontScale=1.0,\n        font=cv2.FONT_HERSHEY_SIMPLEX,\n        lineThickness=1,\n    ):\n        if frame is not None:\n            height, width = frame.shape[:2]\n            # grab the current time stamp and draw it on the frame\n            now = self.timeStamp()\n            if withFrames:\n                now = now + \" %d\" % (self.frames)\n            if withFPS and self.fpsCheck is not None:\n                now = now + \"@%.0f fps\" % (self.fpsCheck.fps())\n            fontFactor = width / 960\n            text_width, text_height = cv2.getTextSize(\n                now, font, fontScale * fontFactor, lineThickness\n            )[0]\n            # https://stackoverflow.com/a/34273603/1497139\n            # frame = frame.copy()\n            self.drawText(\n                frame,\n                now,\n                (width - int(text_width * 1.1), int(text_height * 1.2)),\n                font,\n                fontScale * fontFactor,\n                fontBGRColor,\n                lineThickness,\n            )\n        return frame\n\n    def drawCenteredText(\n        self,\n        frame,\n        text,\n        x,\n        y,\n        fontBGRColor=(0, 255, 0),\n        fontScale=1.0,\n        font=cv2.FONT_HERSHEY_SIMPLEX,\n        lineThickness=1,\n    ):\n        height, width = frame.shape[:2]\n        fontFactor = width / 960\n        text_width, text_height = cv2.getTextSize(\n            text, font, fontScale * fontFactor, lineThickness\n        )[0]\n        self.drawText(\n            frame,\n            text,\n            (x - text_width // 2, y + text_height // 2),\n            font,\n            fontScale * fontFactor,\n            fontBGRColor,\n            lineThickness,\n        )\n\n    def drawText(\n        self,\n        frame,\n        text,\n        bottomLeftCornerOfText,\n        font,\n        fontScale,\n        fontBGRColor,\n        lineThickness,\n    ):\n        cv2.putText(\n            frame,\n            text,\n            bottomLeftCornerOfText,\n            font,\n            fontScale,\n            fontBGRColor,\n            lineThickness,\n        )\n</code></pre>"},{"location":"#pcwawc.video.Video.createBlank","title":"<code>createBlank(width, height, rgb_color=(0, 0, 0))</code>","text":"<p>Create new image(numpy array) filled with certain color in RGB</p> Source code in <code>pcwawc/video.py</code> <pre><code>def createBlank(self, width, height, rgb_color=(0, 0, 0)):\n    \"\"\"Create new image(numpy array) filled with certain color in RGB\"\"\"\n    # Create black blank image\n    image = self.getEmptyImage4WidthAndHeight(width, height, 3)\n\n    # Since OpenCV uses BGR, convert the color first\n    color = tuple(reversed(rgb_color))\n    # Fill image with color\n    image[:] = color\n\n    return image\n</code></pre>"},{"location":"#pcwawc.video.Video.drawPolygon","title":"<code>drawPolygon(image, polygon, color)</code>","text":"<p>draw the given polygon onto the given image with the given color</p> Source code in <code>pcwawc/video.py</code> <pre><code>def drawPolygon(self, image, polygon, color):\n    \"\"\"draw the given polygon onto the given image with the given color\"\"\"\n    cv2.fillConvexPoly(image, polygon, color)\n</code></pre>"},{"location":"#pcwawc.video.Video.drawTrapezoid","title":"<code>drawTrapezoid(image, points, color)</code>","text":"<p>loop over the given points and draw them on the image</p> Source code in <code>pcwawc/video.py</code> <pre><code>def drawTrapezoid(self, image, points, color):\n    \"\"\"loop over the given points and draw them on the image\"\"\"\n    if points is None:\n        return\n    prev = None\n    # if there is exactly four points then close the loop\n    if len(points) == 4:\n        points.append(points[0])\n    for x, y in points:\n        cv2.circle(image, (x, y), 10, color, -1)\n        if prev is not None:\n            cv2.line(image, (x, y), prev, color, 3, cv2.LINE_AA)\n        prev = (x, y)\n</code></pre>"},{"location":"#pcwawc.video.Video.getEmptyImage","title":"<code>getEmptyImage(image, channels=1)</code>","text":"<p>prepare a trapezoid/polygon mask to focus on the square chess field seen as a trapezoid</p> Source code in <code>pcwawc/video.py</code> <pre><code>def getEmptyImage(self, image, channels=1):\n    \"\"\"prepare a trapezoid/polygon mask to focus on the square chess field seen as a trapezoid\"\"\"\n    h, w = image.shape[:2]\n    emptyImage = self.getEmptyImage4WidthAndHeight(w, h, channels)\n    return emptyImage\n</code></pre>"},{"location":"#pcwawc.video.Video.getEmptyImage4WidthAndHeight","title":"<code>getEmptyImage4WidthAndHeight(w, h, channels)</code>","text":"<p>get an empty image with the given width height and channels</p> Source code in <code>pcwawc/video.py</code> <pre><code>def getEmptyImage4WidthAndHeight(self, w, h, channels):\n    \"\"\"get an empty image with the given width height and channels\"\"\"\n    emptyImage = np.zeros((h, w, channels), np.uint8)\n    return emptyImage\n</code></pre>"},{"location":"#pcwawc.video.Video.houghTransform","title":"<code>houghTransform(image)</code>","text":"<p>Performs an Hough Transform to given image.</p> <p>Returns: lines</p> Source code in <code>pcwawc/video.py</code> <pre><code>def houghTransform(self, image):\n    \"\"\"Performs an Hough Transform to given image.\n\n    Returns: lines\"\"\"\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    edges = cv2.Canny(gray, 50, 150, apertureSize=3)\n    lines = cv2.HoughLines(edges, 1, np.pi / 180, 200)\n    return lines\n</code></pre>"},{"location":"#pcwawc.video.Video.houghTransformP","title":"<code>houghTransformP(image)</code>","text":"<p>Performs a probabilistic Hough Transform to given image.</p> <p>Returns: lines</p> Source code in <code>pcwawc/video.py</code> <pre><code>def houghTransformP(self, image):\n    \"\"\"Performs a probabilistic Hough Transform to given image.\n\n    Returns: lines\"\"\"\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    edges = cv2.Canny(gray, 50, 150, apertureSize=3)\n    h, w = image.shape[:2]\n    minLineLength = h / 16\n    maxLineGap = h / 24\n    lines = cv2.HoughLinesP(edges, 1, np.pi / 180, 100, minLineLength, maxLineGap)\n    return lines\n</code></pre>"},{"location":"#pcwawc.video.Video.maskImage","title":"<code>maskImage(image, mask)</code>","text":"<p>return the masked image that filters with the given mask</p> Source code in <code>pcwawc/video.py</code> <pre><code>def maskImage(self, image, mask):\n    \"\"\"return the masked image that filters with the given mask\"\"\"\n    masked = cv2.bitwise_and(image, image, mask=mask)\n    return masked\n</code></pre>"},{"location":"#pcwawc.video.Video.setup","title":"<code>setup(cap)</code>","text":"<p>setup the capturing from the given device</p> Source code in <code>pcwawc/video.py</code> <pre><code>def setup(self, cap):\n    \"\"\"setup the capturing from the given device\"\"\"\n    self.width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n    self.height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n    self.fps = int(cap.get(cv2.CAP_PROP_FPS))\n    self.cap = cap\n    self.fpsCheck = FPSCheck()\n    self.fpsCheck.start()\n</code></pre>"},{"location":"#pcwawc.video.Video.showImage","title":"<code>showImage(image, title, keyCheck=True, keyWait=5)</code>","text":"<p>show the image with the given title</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <p>the image to show</p> required <code>title(str)</code> <p>the title of the image</p> required <code>keyCheck(bool)</code> <p>wait for a a key stroke before continuing?</p> required <code>keyWait(int)</code> <p>maximum number of seconds to wait for a key stroke</p> required Source code in <code>pcwawc/video.py</code> <pre><code>def showImage(self, image, title: str, keyCheck: bool = True, keyWait: int = 5):\n    \"\"\"\n    show the image with the given title\n\n    Args:\n        image: the image to show\n        title(str): the title of the image\n        keyCheck(bool): wait for a a key stroke before continuing?\n        keyWait(int): maximum number of seconds to wait for a key stroke\n    \"\"\"\n    if not threading.current_thread() is threading.main_thread():\n        if self.debug:\n            print(\"can't show image %s since not on mainthread\" % (title))\n        return True\n    if self.headless:\n        return True\n    cv2.imshow(title, image)\n    if keyCheck:\n        return not cv2.waitKey(keyWait) &amp; 0xFF == ord(\"q\")\n    else:\n        return True\n</code></pre>"},{"location":"#pcwawc.video.Video.warp","title":"<code>warp(image, pts, squared=True)</code>","text":"<p>apply the four point transform to obtain a birds eye view of the given image</p> Source code in <code>pcwawc/video.py</code> <pre><code>def warp(self, image, pts, squared=True):\n    \"\"\"apply the four point transform to obtain a birds eye view of the given image\"\"\"\n    warped = perspective.four_point_transform(image, pts)\n    if squared:\n        height, width = warped.shape[:2]\n        side = min(width, height)\n        warped = cv2.resize(warped, (side, side))\n    return warped\n</code></pre>"},{"location":"#pcwawc.video.VideoStream","title":"<code>VideoStream</code>","text":"<p>               Bases: <code>object</code></p> <p>run videograbbing in separate stream</p> Source code in <code>pcwawc/video.py</code> <pre><code>class VideoStream(object):\n    \"\"\"run videograbbing in separate stream\"\"\"\n\n    def __init__(self, video, show=False, postProcess=None, name=\"VideoStream\"):\n        self.video = video\n        self.show = show\n        self.quit = False\n        self.frame = None\n        # initialize the thread name\n        self.name = name\n        self.postProcess = postProcess\n\n        # initialize the variable used to indicate if the thread should\n        # be stopped\n        self.stopped = False\n\n    def start(self):\n        # start the thread to read frames from the video stream\n        t = Thread(target=self.update, name=self.name, args=())\n        t.daemon = True\n        t.start()\n        return self\n\n    def update(self):\n        # keep looping infinitely until the thread is stopped\n        while True:\n            # if the thread indicator variable is set, stop the thread\n            if self.stopped:\n                return\n\n            ret, frame, quitWanted = video.readFrame(self.show, self.postProcess)\n            if quitWanted:\n                return\n\n            if ret:\n                self.frame = frame\n\n    def read(self):\n        # return the frame most recently read\n        return self.frame\n\n    def stop(self):\n        # indicate that the thread should be stopped\n        self.stopped = True\n</code></pre>"},{"location":"#pcwawc.videoanalyze","title":"<code>videoanalyze</code>","text":"<p>Created on 2019-12-08</p> <p>@author: wf</p>"},{"location":"#pcwawc.videoanalyze.VideoAnalyzer","title":"<code>VideoAnalyzer</code>","text":"<p>               Bases: <code>Observable</code></p> <p>analyzer for chessboard videos - may be used from command line or web app</p> Source code in <code>pcwawc/videoanalyze.py</code> <pre><code>class VideoAnalyzer(Observable):\n    \"\"\"analyzer for chessboard videos - may be used from command line or web app\"\"\"\n\n    def __init__(self, args, vision=None, logger=None):\n        super(VideoAnalyzer, self).__init__()\n        if vision is None:\n            self.vision = ChessBoardVision(args)\n        else:\n            self.vision = vision\n        self.logger = logger\n        self.args = args\n        self.debug = args.debug\n        if self.debug:\n            self.log(\"Warp: %s\" % (args.warpPointList))\n\n        # not recording\n        self.videopath = None\n        self.videoout = None\n\n    def open(self):\n        self.vision.open(self.args.input)\n        video = self.vision.video\n        if self.args.startframe &gt; 0:\n            if self.debug:\n                print(\"skipping first %d frames\" % (self.args.startframe))\n            while video.frames &lt;= self.args.startframe:\n                self.vision.video.readFrame()\n\n    def close(self):\n        if self.videoout is not None:\n            self.stopVideoRecording()\n        self.vision.close()\n\n    def hasImage(self):\n        return self.vision.hasImage\n\n    def hasImageSet(self):\n        return self.cbImageSet is not None\n\n    def isRecording(self):\n        return self.videoout is not None\n\n    def startVideoRecording(self, path, filename):\n        self.open()\n        self.videofilename = filename\n        # make sure the path exists\n        Environment.checkDir(path)\n        self.videopath = path + self.videofilename\n        return filename\n\n    def stopVideoRecording(self):\n        self.videoout.release()\n        self.videopath = None\n        self.videoout = None\n        return self.videofilename\n\n    def videoPause(self):\n        ispaused = not self.vision.video.paused()\n        self.vision.video.pause(ispaused)\n        return ispaused\n\n    def analyze(self):\n        self.open()\n        if self.args.autowarp:\n            self.autoWarp()\n        while True:\n            cbImageSet = self.nextImageSet()\n            if cbImageSet is None:\n                break\n            if self.debug:\n                self.vision.video.showImage(cbImageSet.debugImage().image, \"debug\")\n        pgn = self.vision.board.game.pgn\n        self.close()\n        return pgn\n\n    def nextImageSet(self):\n        self.cbImageSet = self.vision.readChessBoardImage()\n        if not self.vision.hasImage:\n            return None\n        self.processImageSet(self.cbImageSet)\n        return self.cbImageSet\n\n    def processImageSet(self, cbImageSet):\n        cbImageSet.warpAndRotate(self.args.nowarp)\n        # analyze the board if warping is active\n        self.fire(cbImageSet=cbImageSet)\n        cbImageSet.prepareGUI()\n        # do we need to record?\n        if self.videopath is not None:\n            cbWarped = cbImageSet.cbWarped\n            # is the output open?\n            if self.videoout is None:\n                # create correctly sized output\n                video = self.vision.video\n                self.videoout = video.prepareRecording(\n                    self.videopath, cbWarped.width, cbWarped.height\n                )\n\n            self.videoout.write(cbWarped.image)\n            self.log(\"wrote frame %d to recording \" % (self.vision.video.frames))\n        return\n\n    def findChessBoard(self):\n        return self.findTheChessBoard(self.vision.video.frame, self.vision.video)\n\n    def findTheChessBoard(self, image, video):\n        finder = BoardFinder(image, video=video)\n        corners = finder.findOuterCorners()\n        # @FIXME - use property title and frame count instead\n        title = \"corners_%s.jpg\" % (video.fileTimeStamp())\n        histograms = finder.getHistograms(image, title, corners)\n        finder.expand(image, title, histograms, corners)\n        if self.debug:\n            corners.showDebug(image, title)\n            finder.showPolygonDebug(image, title, corners)\n            finder.showHistogramDebug(histograms, title, corners)\n        trapez = corners.trapez8x8\n        self.vision.warp.pointList = trapez.tolist()\n        self.vision.warp.updatePoints()\n        return corners\n\n    def log(self, msg):\n        if self.debug:\n            if self.logger is not None:\n                self.logger.info(msg)\n            else:\n                print(msg)\n\n    def setDebug(self, debug):\n        self.debug = debug\n        BoardFinder.debug = debug\n        Corners.debug = debug\n        self.vision.debug = debug\n        if self.moveDetector is not None:\n            self.moveDetector.debug = debug\n\n    def onMove(self, event):\n        move = event.move\n        san = self.vision.board.move(move)\n        if san is None:\n            if self.debug:\n                print(\"invalid move %s\" % (str(move)))\n\n    def autoWarp(self):\n        self.nextImageSet()\n        self.findChessBoard()\n\n    def setUpDetector(self):\n        self.moveDetector = MoveDetectorFactory.create(self.args.detector, self.vision)\n        self.subscribe(self.moveDetector.onChessBoardImage)\n        self.moveDetector.subscribe(self.onMove)\n\n    def changeDetector(self, newDetector):\n        self.unsubscribe(self.moveDetector.onChessBoardImage)\n        self.moveDetector = newDetector\n        self.subscribe(self.moveDetector.onChessBoardImage)\n\n    @staticmethod\n    def fromArgs(argv):\n        cmdLineArgs = Args(\"Chessboard Video analyzer\")\n        args = cmdLineArgs.parse(argv)\n        videoAnalyzer = VideoAnalyzer(args)\n        videoAnalyzer.setUpDetector()\n        videoAnalyzer.setDebug(args.debug)\n        return videoAnalyzer\n</code></pre>"},{"location":"#pcwawc.webapp","title":"<code>webapp</code>","text":""},{"location":"#pcwawc.webapp.WebApp","title":"<code>WebApp</code>","text":"<p>actual Play Chess with a WebCam Application - Flask calls are routed here</p> Source code in <code>pcwawc/webapp.py</code> <pre><code>class WebApp:\n    \"\"\"actual Play Chess with a WebCam Application - Flask calls are routed here\"\"\"\n\n    debug = False\n\n    # construct me with the given settings\n    def __init__(self, args, logger=None):\n        \"\"\"construct me\"\"\"\n        self.args = args\n        self.videoStream = None\n        self.videoAnalyzer = VideoAnalyzer(args, logger=logger)\n        self.videoAnalyzer.setUpDetector()\n        self.board = self.videoAnalyzer.vision.board\n        self.setDebug(args.debug)\n        self.env = Environment()\n\n    def log(self, msg):\n        self.videoAnalyzer.log(msg)\n\n    # return the index.html template content with the given message\n    def index(self, msg):\n        self.log(msg)\n        game = self.board.game\n        game.warp = self.videoAnalyzer.vision.warp\n        game.save()\n        gameid = game.gameid\n        return render_template(\n            \"index.html\",\n            detector=self.videoAnalyzer.moveDetector,\n            detectors=MoveDetectorFactory.detectors,\n            message=msg,\n            timeStamp=self.videoAnalyzer.vision.video.timeStamp(),\n            gameid=gameid,\n        )\n\n    def home(self):\n        self.videoAnalyzer.vision.video = Video()\n        return self.index(\"Home\")\n\n    def photoDownload(self, path, filename):\n        #  https://stackoverflow.com/a/24578372/1497139\n        return send_from_directory(directory=path, filename=filename)\n\n    def setDebug(self, debug):\n        WebApp.debug = debug\n        self.videoAnalyzer.setDebug(debug)\n\n    # toggle the debug flag\n    def chessDebug(self):\n        self.setDebug(not WebApp.debug)\n        msg = \"debug \" + (\"on\" if WebApp.debug else \"off\")\n        return self.index(msg)\n\n    # automatically find the chess board\n    def chessFindBoard(self):\n        if self.videoAnalyzer.hasImage():\n            try:\n                corners = self.videoAnalyzer.findChessBoard()\n                msg = \"%dx%d found\" % (corners.rows, corners.cols)\n            except Exception as e:\n                msg = str(e)\n        else:\n            msg = \"can't find chess board - video is not active\"\n        return self.index(msg)\n\n    def chessTakeback(self):\n        try:\n            msg = \"take back\"\n            if not self.board.takeback():\n                msg = \"can not take back any more moves\"\n            if WebApp.debug:\n                self.game.showDebug()\n            return self.index(msg)\n        except BaseException as e:\n            return self.indexException(e)\n\n    def chessSave(self):\n        gameid = self.board.lockGame()\n        msg = \"chess game &lt;a href='/chess/games/%s'&gt;%s&lt;/a&gt; saved(locked)\" % (\n            gameid,\n            gameid,\n        )\n        return self.index(msg)\n\n    def chessGameColors(self):\n        msg = \"color update in progress\"\n        return self.index(msg)\n\n    def chessForward(self):\n        msg = \"forward\"\n        return self.index(msg)\n\n    def indexException(self, e):\n        msg = \"&lt;span style='color:red'&gt;%s&lt;/span&gt;\" % str(e)\n        return self.index(msg)\n\n    def chessMove(self, move):\n        try:\n            if \"-\" in move:\n                move = move.replace(\"-\", \"\")\n            self.board.ucimove(move)\n            msg = \"move %s -&gt; fen= %s\" % (move, self.board.fen)\n            if WebApp.debug:\n                self.game.showDebug()\n            return self.index(msg)\n        except BaseException as e:\n            return self.indexException(e)\n\n    def timeStamp(self):\n        return datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S.%f\")\n\n    def chessGameState(self, gameid):\n        fen = self.board.fen\n        pgn = self.board.game.pgn\n        gameStateJson = jsonify(\n            fen=fen,\n            pgn=pgn,\n            gameid=gameid,\n            debug=WebApp.debug,\n            timestamp=self.timeStamp(),\n        )\n        # if WebApp.debug:\n        #    self.log(gameStateJson)\n        return gameStateJson\n\n    def chessSettings(self, args):\n        msg = \"settings\"\n        if \"detector\" in args:\n            newDetectorName = args[\"detector\"]\n            newDetector = MoveDetectorFactory.create(\n                newDetectorName, self.videoAnalyzer.vision\n            )\n            self.videoAnalyzer.changeDetector(newDetector)\n            msg = \"changing detector to %s\" % (newDetectorName)\n        return self.index(msg)\n\n    def chessFEN(self, fen):\n        msg = fen\n        try:\n            self.board.updatePieces(fen)\n            msg = \"game update from fen %s\" % (fen)\n            return self.index(msg)\n        except BaseException as e:\n            return self.indexException(e)\n\n    def chessPgn(self, pgn):\n        try:\n            self.board.setPgn(pgn)\n            msg = \"game updated from pgn\"\n            return self.index(msg)\n        except BaseException as e:\n            return self.indexException(e)\n\n    # picture has been clicked\n    def chessWebCamClick(self, x, y, w, h):\n        video = self.videoAnalyzer.vision.video\n        if not self.videoAnalyzer.hasImage():\n            msg = \"no video available\"\n        else:\n            px = x * video.width // w\n            py = y * video.height // h\n            b, g, r = video.frame[py, px]\n            colorInfo = \"r:%x g:%x b:%x\" % (r, g, b)\n            warp = self.videoAnalyzer.vision.warp\n            warp.addPoint(px, py)\n            msg = (\n                \"clicked warppoint %d pixel %d,%d %s mouseclick %d,%d in image %d x %d\"\n                % (len(warp.pointList), px, py, colorInfo, x, y, w, h)\n            )\n            return self.index(msg)\n\n    def photo(self, path):\n        try:\n            if self.videoAnalyzer.hasImageSet():\n                # make sure the path exists\n                Environment.checkDir(path)\n                video = self.videoAnalyzer.vision.video\n                filename = \"chessboard_%s.jpg\" % (video.fileTimeStamp())\n                video.writeImage(\n                    self.videoAnalyzer.cbImageSet.cbGUI.image, path + filename\n                )\n                msg = \"still image &lt;a href='/photo/%s'&gt;%s&lt;/a&gt; taken from input %s\" % (\n                    filename,\n                    filename,\n                    self.args.input,\n                )\n            else:\n                msg = \"no imageset for photo available\"\n            return self.index(msg)\n        except BaseException as e:\n            return self.indexException(e)\n\n    def videoRecord(self, path):\n        if not self.videoAnalyzer.isRecording():\n            video = self.videoAnalyzer.vision.video\n            filename = self.videoAnalyzer.startVideoRecording(\n                path, \"chessgame_%s.avi\" % (video.fileTimeStamp())\n            )\n            msg = \"started recording %s\" % (filename)\n        else:\n            filename = self.videoAnalyzer.stopVideoRecording()\n            msg = \"finished recording \" + filename\n        return self.index(msg)\n\n    def videoRotate90(self):\n        try:\n            warp = self.videoAnalyzer.vision.warp\n            warp.rotate(90)\n            msg = \"rotation: %d\u00b0\" % (warp.rotation)\n            return self.index(msg)\n        except BaseException as e:\n            return self.indexException(e)\n\n    def videoPause(self):\n        ispaused = self.videoAnalyzer.videoPause()\n        msg = \"video \" + (\"paused\" if ispaused else \"running\")\n        return self.index(msg)\n\n    def videoFeed(self):\n        self.videoAnalyzer.open()\n        # return the response generated along with the specific media\n        # type (mime type)\n        return Response(\n            self.genVideo(self.videoAnalyzer),\n            mimetype=\"multipart/x-mixed-replace; boundary=frame\",\n        )\n\n    # https://html.spec.whatwg.org/multipage/server-sent-events.html\n    # https://stackoverflow.com/a/51969441/1497139\n    def getEvent(self):\n        \"\"\"this could be any function that blocks until data is ready\"\"\"\n        time.sleep(1.0)\n        s = datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\n        return s\n\n    def eventFeed(self):\n        return Response(self.genEventStream(), mimetype=\"text/event-stream\")\n\n    def genEventStream(self):\n        while True:\n            # wait for source data to be available, then push it\n            yield \"data: {}\\n\\n\".format(self.getEvent())\n\n    # streamed video generator\n    # @TODO fix this non working code\n    # def genVideoStreamed(self, video):\n    #    if self.videoStream is None:\n    #        self.videoStream = VideoStream(self.video, show=True, postProcess=self.video.addTimeStamp)\n    #        self.videoStream.start()\n    #    while True:\n    #        frame = self.videoStream.read()\n    #        if frame is not None:\n    #            flag, encodedImage = self.video.imencode(frame)\n    #            # ensure we got a valid image\n    #            if not flag:\n    #                continue\n    #            # yield the output frame in the byte format\n    #            yield(b'--frame\\r\\n' b'Content-Type: image/jpeg\\r\\n\\r\\n' +\n    #                  bytearray(encodedImage) + b'\\r\\n')\n\n    # video generator\n    def genVideo(self, analyzer):\n        if self.args.autowarp:\n            analyzer.autoWarp()\n        while True:\n            cbImageSet = analyzer.nextImageSet()\n            if cbImageSet is None:\n                break\n            guiImage = cbImageSet.cbGUI.image\n            if guiImage is not None:\n                (flag, encodedImage) = analyzer.vision.video.imencode(guiImage)\n                if not flag:\n                    self.log(\"encoding failed\")\n                else:\n                    # yield the output frame in the byte format\n                    yield (\n                        b\"--frame\\r\\n\"\n                        b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n                        + bytearray(encodedImage)\n                        + b\"\\r\\n\"\n                    )\n</code></pre>"},{"location":"#pcwawc.webapp.WebApp.__init__","title":"<code>__init__(args, logger=None)</code>","text":"<p>construct me</p> Source code in <code>pcwawc/webapp.py</code> <pre><code>def __init__(self, args, logger=None):\n    \"\"\"construct me\"\"\"\n    self.args = args\n    self.videoStream = None\n    self.videoAnalyzer = VideoAnalyzer(args, logger=logger)\n    self.videoAnalyzer.setUpDetector()\n    self.board = self.videoAnalyzer.vision.board\n    self.setDebug(args.debug)\n    self.env = Environment()\n</code></pre>"},{"location":"#pcwawc.webapp.WebApp.getEvent","title":"<code>getEvent()</code>","text":"<p>this could be any function that blocks until data is ready</p> Source code in <code>pcwawc/webapp.py</code> <pre><code>def getEvent(self):\n    \"\"\"this could be any function that blocks until data is ready\"\"\"\n    time.sleep(1.0)\n    s = datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return s\n</code></pre>"},{"location":"#pcwawc.webchesscam","title":"<code>webchesscam</code>","text":""},{"location":"#pcwawc.webchesscam.WebChessCamArgs","title":"<code>WebChessCamArgs</code>","text":"<p>               Bases: <code>Args</code></p> <p>This class parses command line arguments and generates a usage.</p> Source code in <code>pcwawc/webchesscam.py</code> <pre><code>class WebChessCamArgs(Args):\n    \"\"\"This class parses command line arguments and generates a usage.\"\"\"\n\n    def __init__(self, argv):\n        super().__init__(description=\"WebChessCam\")\n        self.parser.add_argument(\n            \"--port\", type=int, default=\"5003\", help=\"port to run server at\"\n        )\n\n        self.parser.add_argument(\n            \"--host\", default=\"0.0.0.0\", help=\"host to allow access for\"\n        )\n\n        self.args = self.parse(argv)\n</code></pre>"},{"location":"#pcwawc.webchesscam.chessUpdate","title":"<code>chessUpdate()</code>","text":"<p>set game status from the given pgn, fen or move</p> Source code in <code>pcwawc/webchesscam.py</code> <pre><code>@app.route(\"/chess/update\", methods=[\"GET\"])\ndef chessUpdate():\n    \"\"\"set game status from the given pgn, fen or move\"\"\"\n    updateGame = request.args.get(\"updateGame\")\n    updateFEN = request.args.get(\"updateFEN\")\n    updateMove = request.args.get(\"updateMove\")\n    pgn = request.args.get(\"pgn\")\n    fen = request.args.get(\"fen\")\n    move = request.args.get(\"move\")\n    if updateFEN is not None:\n        return webApp.chessFEN(fen)\n    elif updateGame is not None:\n        return webApp.chessPgn(pgn)\n    elif updateMove is not None:\n        return webApp.chessMove(move)\n    else:\n        return webApp.index(\n            \"expected updateGame,updateFEN or updateMove but no such request found\"\n        )\n</code></pre>"},{"location":"#pcwawc.yamlablemixin","title":"<code>yamlablemixin</code>","text":""},{"location":"#pcwawc.yamlablemixin.YamlAbleMixin","title":"<code>YamlAbleMixin</code>","text":"<p>               Bases: <code>object</code></p> <p>allow reading and writing derived objects from a yaml file</p> Source code in <code>pcwawc/yamlablemixin.py</code> <pre><code>class YamlAbleMixin(object):\n    \"\"\"allow reading and writing derived objects from a yaml file\"\"\"\n\n    debug = False\n\n    # read me from a yaml file\n    @staticmethod\n    def readYaml(name):\n        yamlFile = name\n        if not yamlFile.endswith(\".yaml\"):\n            yamlFile = yamlFile + \".yaml\"\n        # is there a yamlFile for the given name\n        if os.path.isfile(yamlFile):\n            with io.open(yamlFile, \"r\") as stream:\n                if YamlAbleMixin.debug:\n                    print(\"reading %s\" % (yamlFile))\n                result = yaml.load(stream, Loader=yaml.Loader)\n                if YamlAbleMixin.debug:\n                    print(result)\n                return result\n        else:\n            return None\n\n    # write me to my yaml file\n    def writeYaml(self, name):\n        yamlFile = name\n        if not yamlFile.endswith(\".yaml\"):\n            yamlFile = yamlFile + \".yaml\"\n        with io.open(yamlFile, \"w\", encoding=\"utf-8\") as stream:\n            yaml.dump(self, stream)\n            if YamlAbleMixin.debug:\n                print(yaml.dump(self))\n</code></pre>"}]}